<!DOCTYPE html>
<html data-color-mode="light" data-dark-theme="dark_colorblind" data-light-theme="light" lang="zh-CN">
<head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link href='https://mirrors.sustech.edu.cn/cdnjs/ajax/libs/Primer/21.0.7/primer.css' rel='stylesheet' />
    
    <link rel="icon" href="https://github.githubassets.com/favicons/favicon.svg"><script>
        let theme = localStorage.getItem("meek_theme") || "light";
        document.documentElement.setAttribute("data-color-mode", theme);
    </script>
<meta name="description" content="[Advent of Code](https://adventofcode.com/)

使用 python 编写, 没有整理代码, 所以非常乱(变量乱取名, 没有注释, 逻辑奇怪, 并非最佳实现)
可以使用 gpt 相关工具辅助查看

> 如果没有特意说明, 变量 a 统一存放所有原始字符串

## 第九题

[https://adventofcode.com/2024/day/9](https://adventofcode.com/2024/day/9)

### 1题

一个磁盘中的文件表示方法, 每两位数字各表示, x块文件, x块空的区域
例如
`12345`
表示 一块文件 两块空文件 三块文件 四块空文件 五块文件
每个文件从前往后的id为他们在磁盘中的顺序, 例如上述可以表示为
`0..111....22222`

希望从后往前的将文件塞入从前往后中空的地方

例如
```text
0..111....22222
02.111....2222.
022111....222..
0221112...22...
02211122..2....
022111222......
```

最后输出每个块位置*id号之和

<details><summary>Details</summary>
<p>

```python
# 构建
t = []
flag = True
file_id = 0
for i in list(a):
    if flag:
        for _ in range(int(i)):
            t.append(file_id)
        flag = False
        file_id += 1
    else:
        for _ in range(int(i)):
            t.append('.')
        flag = True

i = 0
j = len(t) - 1

while i < j:
    if t[i] == '.':
        if t[j] != '.':
            t[i], t[j] = t[j], t[i]
        else:
            i -= 1
        j -= 1
    i += 1

ans = 0
for i, j in enumerate(t):
    if j != '.':
        ans += i * j
print(ans)

```

</p>
</details> 

### 2题

在一题的基础上, 修改从后往前放入从前往后空区域的方法, 从单个块移动转换为整个文件移动, 例如
```text
00...111...2...333.44.5555.6666.777.888899
0099.111...2...333.44.5555.6666.777.8888..
0099.1117772...333.44.5555.6666.....8888..
0099.111777244.333....5555.6666.....8888..
00992111777.44.333....5555.6666.....8888..
```

最后输出每个块位置*id号之和

<details><summary>Details</summary>
<p>

```python
# 构建
t = []
flag = True
file_id = 0
for i in list(a):
    if flag:
        for _ in range(int(i)):
            t.append(file_id)
        flag = False
        file_id += 1
    else:
        for _ in range(int(i)):
            t.append('.')
        flag = True


def get_file_size(file_id):
    return t.count(file_id)

for i in range(file_id - 1, -1, -1):
    file_size = get_file_size(i)
    file_index = t.index(i)
    flag = False
    size = 0
    for id, j in enumerate(t):
        if j == '.':
            flag = True
        else:
            flag = False
            size = 0
        
        if flag:
            size += 1
            if size == file_size:
                # change位置
                for k in range(id, id - file_size, -1):
                    t[k], t[file_index] = t[file_index], t[k]
                    file_index += 1

                break
        if id >= file_index:
            break

ans = 0
for i, j in enumerate(t):
    if j != '.':
        ans += i * j
print(ans)

```

</p>
</details> 

## 第十题

[https://adventofcode.com/2024/day/10](https://adventofcode.com/2024/day/10)

### 1题

给定一幅由数字组成的地图, 从 0 开始, 一步一步上下左右移动到 9
求一副图中, 每一个 0 能到达的 9 有多少个, 输出他们的和

<details><summary>Details</summary>
<p>

```python
aaa = []
for i in a.splitlines():
    aaa.append(list(map(int, list(i))))

# print(aaa)

# 获取所有 0 跟 9 的位置
pos_0 = []
pos_9 = []
for i in range(len(aaa)):
    for j in range(len(aaa[i])):
        if aaa[i][j] == 0:
            pos_0.append((i, j))
        elif aaa[i][j] == 9:
            pos_9.append((i, j))

def get_allow_pos(pos):
    for i in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        next_step = (pos[0] + i[0], pos[1] + i[1])
        if len(aaa) > next_step[0] >= 0 and len(aaa[0]) > next_step[1] >= 0:
            if aaa[next_step[0]][next_step[1]] == aaa[pos[0]][pos[1]] + 1:
                yield (pos[0] + i[0], pos[1] + i[1])


def dfs(pos, pos_9):
    if pos == pos_9:
        return 1
    aa = 0
    for p in get_allow_pos(pos):
        aa = dfs(p, pos_9)
        if aa > 0:
            return aa
    return aa

ans = 0
for i in pos_0:
    for j in pos_9:
        ans += dfs(i, j)

print(ans)

``` 

</p>
</details> 

### 2题

求 0 到每一个 9 有多少种不同的走法 (注意与第一题的区别, 第一题只要求到达, 第二题需要找到所有路线)

<details><summary>Details</summary>
<p>

```python
aaa = []
for i in a.splitlines():
    aaa.append(list(map(int, list(i))))

# print(aaa)

# 获取所有 0 跟 9 的位置
pos_0 = []
pos_9 = []
for i in range(len(aaa)):
    for j in range(len(aaa[i])):
        if aaa[i][j] == 0:
            pos_0.append((i, j))
        elif aaa[i][j] == 9:
            pos_9.append((i, j))

def get_allow_pos(pos):
    for i in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        next_step = (pos[0] + i[0], pos[1] + i[1])
        if len(aaa) > next_step[0] >= 0 and len(aaa[0]) > next_step[1] >= 0:
            if aaa[next_step[0]][next_step[1]] == aaa[pos[0]][pos[1]] + 1:
                yield (pos[0] + i[0], pos[1] + i[1])


def dfs(pos, pos_9):
    if pos == pos_9:
        return 1
    aa = 0
    for p in get_allow_pos(pos):
        aa = dfs(p, pos_9)
        if aa > 0:
            return aa
    return aa

ans = 0
for i in pos_0:
    for j in pos_9:
        ans += dfs(i, j)

print(ans)

```

</p>
</details> 

> 在一题的基础上, dfs固定返回1 变成 dfs 返回上一次dfs + 1

## 第十一题

[https://adventofcode.com/2024/day/11](https://adventofcode.com/2024/day/11)

### 1题

给定一串数字, 根据以下规则变换

1. 如果数字是0, 则数字是1
2. 如果数字是偶数位, 则数字变成两个数字, 左半跟右半, 例如 1000 变成 10 跟 00, 不保留前导0, 00变成0
3. 如果没有碰到前两条规则, 则数字=数字*2024

顺序都会被保留 (但是这题没有用到, 而且会误导第二题)
模拟上述规则25次

<details><summary>Details</summary>
<p>

```python
aa = a.split(' ')

for _ in range(25):
    i = 0
    while i < len(aa):
        if aa[i] == '0':
            aa[i] = '1'
        elif len(aa[i]) % 2 == 0:
            left = aa[i][:len(aa[i]) // 2]
            left = str(int(left))
            right = aa[i][len(aa[i]) // 2:]
            right = str(int(right))
            aa.insert(i+1, right)
            aa[i] = left
            i += 1
        else:
            aa[i] = str(int(aa[i]) * 2024)
        
        i += 1

print(len(aa))
```

</p>
</details> 

> 模拟即可, 25次蛮少的可以直接出来

### 2题

在1题的基础上, 模拟75次

<details><summary>Details</summary>
<p>

```python
from collections import defaultdict
from tqdm import tqdm
aa = list(map(int, a.split(' ')))

def get_length(num):
    i = 0
    while num > 0:
        num //= 10
        i += 1
    return i

t = defaultdict(int)

for i in aa:
    t[i] += 1

for _ in tqdm(range(75)):
    tt = defaultdict(int)
    for i, j in t.items():
        length = get_length(i)
        if i == 0:
            tt[1] += j
        elif length % 2 == 0:
            tt[i // 10 ** (length // 2)] += j
            tt[i % 10 ** (length // 2)] += j
        else:
            tt[i * 2024] += j
        
        t = tt

print(sum(t.values()))
```

</p>
</details> 

> `tqdm` 是为了监控速度, 非必要引入
> 与第一题不同, 这题指数爆炸, 75次会超时, 因为答案不要求顺序, 所以可以用缓存

## 第十二题

[https://adventofcode.com/2024/day/12](https://adventofcode.com/2024/day/12)

### 1题

划分区域

```text
AAAA
BBCD
BBCC
EEEC
```

划分成

```text
+-+-+-+-+
|A A A A|
+-+-+-+-+     +-+
              |D|
+-+-+   +-+   +-+
|B B|   |C|
+   +   + +-+
|B B|   |C C|
+-+-+   +-+ +
          |C|
+-+-+-+   +-+
|E E E|
+-+-+-+
```

分为五个区域, 
计算每个区域的周长*面积之和

<details><summary>Details</summary>
<p>

```python

aa = []
for i in a.splitlines():
    aa.append(list(i))

def get_perimeter(arr):
    perimeter = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                perimeter += 4
                if i > 0 and arr[i - 1][j] == 1:
                    perimeter -= 1
                if j > 0 and arr[i][j - 1] == 1:
                    perimeter -= 1
                if i < len(arr) - 1 and arr[i + 1][j] == 1:
                    perimeter -= 1
                if j < len(arr[0]) - 1 and arr[i][j + 1] == 1:
                    perimeter -= 1
    
    return perimeter

def get_area(arr):
    area = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                area += 1
    return area

def get_allow_pos(pos):
    allow_pos = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    char = aa[pos[0]][pos[1]]
    for i in allow_pos:
        next_pos = (pos[0] + i[0], pos[1] + i[1])
        if len(aa) > next_pos[0] >= 0 and len(aa[0]) > next_pos[1] >= 0:
            if aa[next_pos[0]][next_pos[1]] == char:
                yield next_pos


ans = 0

already_visited = np.zeros((len(aa), len(aa[0])))
for i in range(len(aa)):
    for j in range(len(aa[i])):
        if already_visited[i][j] == 0:
            # print(aa[i][j])
            array_ = np.zeros((len(aa), len(aa[0])))
            already_visited[i][j] = 1
            array_[i][j] = 1
            def dfs(pos):
                for next_pos in get_allow_pos(pos):
                    if already_visited[next_pos[0]][next_pos[1]] == 0:
                        already_visited[next_pos[0]][next_pos[1]] = 1
                        array_[next_pos[0]][next_pos[1]] = 1
                        dfs(next_pos)
            
            dfs((i, j))
            area = get_area(array_)
            perimeter = get_perimeter(array_)
            ans += area * perimeter
        
print(ans)

```

</p>
</details> 

> 加一个正方形边长+4, 如果旁边每有一个正方形就-1的边长

### 2题

1题的边长变成边的数量

<details><summary>Details</summary>
<p>

```python

aa = []
for i in a.splitlines():
    aa.append(list(i))



def get_area(arr):
    area = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                area += 1
    return area

def get_perimeter(region):
        
    max_x = len(region) - 1
    max_y = len(region[0]) - 1
    min_x = min_y = 0
    
    def state(x, y):
        if x < 0 or x > max_x or y < 0 or y > max_y:
            return False
        return region[x][y]
    
    perimeter = 0
    
    # 垂直方向扫描
    for i in range(max_x + 1):
        st = state(i, -1)
        for j in range(max_y + 2):
            if st != state(i, j):
                if st != state(i-1, j-1) or st == state(i-1, j):
                    perimeter += 1
                if st != state(i+1, j-1) or st == state(i+1, j):
                    perimeter += 1
                st = not st
    
    # 水平方向扫描
    for j in range(max_y + 1):
        st = state(-1, j)
        for i in range(max_x + 2):
            if st != state(i, j):
                if st != state(i-1, j-1) or st == state(i, j-1):
                    perimeter += 1
                if st != state(i-1, j+1) or st == state(i, j+1):
                    perimeter += 1
                st = not st
    
    return perimeter // 2

def get_allow_pos(pos):
    allow_pos = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    char = aa[pos[0]][pos[1]]
    for i in allow_pos:
        next_pos = (pos[0] + i[0], pos[1] + i[1])
        if len(aa) > next_pos[0] >= 0 and len(aa[0]) > next_pos[1] >= 0:
            if aa[next_pos[0]][next_pos[1]] == char:
                yield next_pos

ans = 0

already_visited = np.zeros((len(aa), len(aa[0])))
for i in range(len(aa)):
    for j in range(len(aa[i])):
        if already_visited[i][j] == 0:
            # print(aa[i][j])
            array_ = np.zeros((len(aa), len(aa[0])))
            already_visited[i][j] = 1
            array_[i][j] = 1
            def dfs(pos):
                for next_pos in get_allow_pos(pos):
                    if already_visited[next_pos[0]][next_pos[1]] == 0:
                        already_visited[next_pos[0]][next_pos[1]] = 1
                        array_[next_pos[0]][next_pos[1]] = 1
                        
                        dfs(next_pos)
            
            dfs((i, j))
            area = get_area(array_)
            perimeter = get_perimeter(array_)
            # print(perimeter)
            ans += area * perimeter
        
print(ans)

```

</p>
</details> 

> 一条边有两个角, 找到所有角之后整除2即可

## 第十三题

[https://adventofcode.com/2024/day/13](https://adventofcode.com/2024/day/13)

### 1题

按下按钮A或B, 移动老虎爪, 让老虎爪移动到指定的位置, 按下A需要三块钱, B需要一块钱
有可能无解(无法移动到指定位置)

<details><summary>Details</summary>
<p>

```python

aa = a.split('\n\n')
from sympy import *

ans = 0
for i in aa:
    inputs = i.split('\n')
    # 提取输入
    ax, ay = inputs[0].split(': ')[1].split(', ')
    bx, by = inputs[1].split(': ')[1].split(', ')
    t1, t2 = inputs[2].split(': ')[1].split(', ')
    ax, ay = int(ax[2:]), int(ay[2:])
    bx, by = int(bx[2:]), int(by[2:])
    t1, t2 = int(t1[2:]), int(t2[2:])
    m = Symbol('m')
    n = Symbol('n')
    temp = solve([m * ax + n * bx - t1, m * ay + n * by - t2], [m, n])
    # print(temp)
    if temp[m].is_Integer and temp[n].is_Integer:
        ans += int(temp[m]) * 3 + int(temp[n])

print(ans)

```

</p>
</details> 
> 二元一次方程组的整数解

### 2题

在一题的基础上, X轴和Y轴上都高出10000000000000(大数)

<details><summary>Details</summary>
<p>

```python

aa = a.split('\n\n')
from sympy import *

ans = 0
for i in aa:
    inputs = i.split('\n')
    # 提取输入
    ax, ay = inputs[0].split(': ')[1].split(', ')
    bx, by = inputs[1].split(': ')[1].split(', ')
    t1, t2 = inputs[2].split(': ')[1].split(', ')
    ax, ay = int(ax[2:]), int(ay[2:])
    bx, by = int(bx[2:]), int(by[2:])
    t1, t2 = int(t1[2:]) + 10000000000000, int(t2[2:]) + 10000000000000
    m = Symbol('m')
    n = Symbol('n')
    temp = solve([m * ax + n * bx - t1, m * ay + n * by - t2], [m, n])
    # print(temp)
    if temp[m].is_Integer and temp[n].is_Integer:
        ans += int(temp[m]) * 3 + int(temp[n])

print(ans)
```

</p>
</details> 

> python无限精度整数, 不需要额外处理

## 第十四题

[https://adventofcode.com/2024/day/14](https://adventofcode.com/2024/day/14)

### 1题

给定点坐标, 点的移动速度, 大小固定的图

求 四个象限内点的数量 之积
象限是去掉最中间一列与一行使得图分成四个区域
点到边界会传送到另一侧 (mod)

<details><summary>Details</summary>
<p>

```python

def main():
    lines = a.splitlines()

    robots = []
    for line in lines:
        p_part, v_part = line.strip().split()
        p_x, p_y = map(int, p_part[2:].split(','))
        v_x, v_y = map(int, v_part[2:].split(','))
        robots.append({'p': (p_x, p_y), 'v': (v_x, v_y)})

    positions = {}
    for robot in robots:
        x = (robot['p'][0] + robot['v'][0] * 100) % 101
        y = (robot['p'][1] + robot['v'][1] * 100) % 103
        positions[(x, y)] = positions.get((x, y), 0) + 1

    q1 = q2 = q3 = q4 = 0
    for (x, y), count in positions.items():
        if x < 50 and y < 51:
            q1 += count
        elif x > 50 and y < 51:
            q2 += count
        elif x > 50 and y > 51:
            q3 += count
        elif x < 50 and y > 51:
            q4 += count

    safety_factor = q1 * q2 * q3 * q4
    print(safety_factor)

if __name__ == '__main__':
    main()

```

</p>
</details> 

### 2题

直接贴原题, 因为原题是阅读理解

During the bathroom break, someone notices that these robots seem awfully similar to ones built and used at the North Pole. If they're the same type of robots, they should have a hard-coded Easter egg: very rarely, most of the robots should arrange themselves into a picture of a Christmas tree.
> 在上厕所的时候，有人注意到这些机器人看起来与在北极建造和使用的机器人非常相似。">
<meta property="og:title" content="2024 Advent of Code 复盘与答案 (二) (9-16题)">
<meta property="og:description" content="[Advent of Code](https://adventofcode.com/)

使用 python 编写, 没有整理代码, 所以非常乱(变量乱取名, 没有注释, 逻辑奇怪, 并非最佳实现)
可以使用 gpt 相关工具辅助查看

> 如果没有特意说明, 变量 a 统一存放所有原始字符串

## 第九题

[https://adventofcode.com/2024/day/9](https://adventofcode.com/2024/day/9)

### 1题

一个磁盘中的文件表示方法, 每两位数字各表示, x块文件, x块空的区域
例如
`12345`
表示 一块文件 两块空文件 三块文件 四块空文件 五块文件
每个文件从前往后的id为他们在磁盘中的顺序, 例如上述可以表示为
`0..111....22222`

希望从后往前的将文件塞入从前往后中空的地方

例如
```text
0..111....22222
02.111....2222.
022111....222..
0221112...22...
02211122..2....
022111222......
```

最后输出每个块位置*id号之和

<details><summary>Details</summary>
<p>

```python
# 构建
t = []
flag = True
file_id = 0
for i in list(a):
    if flag:
        for _ in range(int(i)):
            t.append(file_id)
        flag = False
        file_id += 1
    else:
        for _ in range(int(i)):
            t.append('.')
        flag = True

i = 0
j = len(t) - 1

while i < j:
    if t[i] == '.':
        if t[j] != '.':
            t[i], t[j] = t[j], t[i]
        else:
            i -= 1
        j -= 1
    i += 1

ans = 0
for i, j in enumerate(t):
    if j != '.':
        ans += i * j
print(ans)

```

</p>
</details> 

### 2题

在一题的基础上, 修改从后往前放入从前往后空区域的方法, 从单个块移动转换为整个文件移动, 例如
```text
00...111...2...333.44.5555.6666.777.888899
0099.111...2...333.44.5555.6666.777.8888..
0099.1117772...333.44.5555.6666.....8888..
0099.111777244.333....5555.6666.....8888..
00992111777.44.333....5555.6666.....8888..
```

最后输出每个块位置*id号之和

<details><summary>Details</summary>
<p>

```python
# 构建
t = []
flag = True
file_id = 0
for i in list(a):
    if flag:
        for _ in range(int(i)):
            t.append(file_id)
        flag = False
        file_id += 1
    else:
        for _ in range(int(i)):
            t.append('.')
        flag = True


def get_file_size(file_id):
    return t.count(file_id)

for i in range(file_id - 1, -1, -1):
    file_size = get_file_size(i)
    file_index = t.index(i)
    flag = False
    size = 0
    for id, j in enumerate(t):
        if j == '.':
            flag = True
        else:
            flag = False
            size = 0
        
        if flag:
            size += 1
            if size == file_size:
                # change位置
                for k in range(id, id - file_size, -1):
                    t[k], t[file_index] = t[file_index], t[k]
                    file_index += 1

                break
        if id >= file_index:
            break

ans = 0
for i, j in enumerate(t):
    if j != '.':
        ans += i * j
print(ans)

```

</p>
</details> 

## 第十题

[https://adventofcode.com/2024/day/10](https://adventofcode.com/2024/day/10)

### 1题

给定一幅由数字组成的地图, 从 0 开始, 一步一步上下左右移动到 9
求一副图中, 每一个 0 能到达的 9 有多少个, 输出他们的和

<details><summary>Details</summary>
<p>

```python
aaa = []
for i in a.splitlines():
    aaa.append(list(map(int, list(i))))

# print(aaa)

# 获取所有 0 跟 9 的位置
pos_0 = []
pos_9 = []
for i in range(len(aaa)):
    for j in range(len(aaa[i])):
        if aaa[i][j] == 0:
            pos_0.append((i, j))
        elif aaa[i][j] == 9:
            pos_9.append((i, j))

def get_allow_pos(pos):
    for i in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        next_step = (pos[0] + i[0], pos[1] + i[1])
        if len(aaa) > next_step[0] >= 0 and len(aaa[0]) > next_step[1] >= 0:
            if aaa[next_step[0]][next_step[1]] == aaa[pos[0]][pos[1]] + 1:
                yield (pos[0] + i[0], pos[1] + i[1])


def dfs(pos, pos_9):
    if pos == pos_9:
        return 1
    aa = 0
    for p in get_allow_pos(pos):
        aa = dfs(p, pos_9)
        if aa > 0:
            return aa
    return aa

ans = 0
for i in pos_0:
    for j in pos_9:
        ans += dfs(i, j)

print(ans)

``` 

</p>
</details> 

### 2题

求 0 到每一个 9 有多少种不同的走法 (注意与第一题的区别, 第一题只要求到达, 第二题需要找到所有路线)

<details><summary>Details</summary>
<p>

```python
aaa = []
for i in a.splitlines():
    aaa.append(list(map(int, list(i))))

# print(aaa)

# 获取所有 0 跟 9 的位置
pos_0 = []
pos_9 = []
for i in range(len(aaa)):
    for j in range(len(aaa[i])):
        if aaa[i][j] == 0:
            pos_0.append((i, j))
        elif aaa[i][j] == 9:
            pos_9.append((i, j))

def get_allow_pos(pos):
    for i in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        next_step = (pos[0] + i[0], pos[1] + i[1])
        if len(aaa) > next_step[0] >= 0 and len(aaa[0]) > next_step[1] >= 0:
            if aaa[next_step[0]][next_step[1]] == aaa[pos[0]][pos[1]] + 1:
                yield (pos[0] + i[0], pos[1] + i[1])


def dfs(pos, pos_9):
    if pos == pos_9:
        return 1
    aa = 0
    for p in get_allow_pos(pos):
        aa = dfs(p, pos_9)
        if aa > 0:
            return aa
    return aa

ans = 0
for i in pos_0:
    for j in pos_9:
        ans += dfs(i, j)

print(ans)

```

</p>
</details> 

> 在一题的基础上, dfs固定返回1 变成 dfs 返回上一次dfs + 1

## 第十一题

[https://adventofcode.com/2024/day/11](https://adventofcode.com/2024/day/11)

### 1题

给定一串数字, 根据以下规则变换

1. 如果数字是0, 则数字是1
2. 如果数字是偶数位, 则数字变成两个数字, 左半跟右半, 例如 1000 变成 10 跟 00, 不保留前导0, 00变成0
3. 如果没有碰到前两条规则, 则数字=数字*2024

顺序都会被保留 (但是这题没有用到, 而且会误导第二题)
模拟上述规则25次

<details><summary>Details</summary>
<p>

```python
aa = a.split(' ')

for _ in range(25):
    i = 0
    while i < len(aa):
        if aa[i] == '0':
            aa[i] = '1'
        elif len(aa[i]) % 2 == 0:
            left = aa[i][:len(aa[i]) // 2]
            left = str(int(left))
            right = aa[i][len(aa[i]) // 2:]
            right = str(int(right))
            aa.insert(i+1, right)
            aa[i] = left
            i += 1
        else:
            aa[i] = str(int(aa[i]) * 2024)
        
        i += 1

print(len(aa))
```

</p>
</details> 

> 模拟即可, 25次蛮少的可以直接出来

### 2题

在1题的基础上, 模拟75次

<details><summary>Details</summary>
<p>

```python
from collections import defaultdict
from tqdm import tqdm
aa = list(map(int, a.split(' ')))

def get_length(num):
    i = 0
    while num > 0:
        num //= 10
        i += 1
    return i

t = defaultdict(int)

for i in aa:
    t[i] += 1

for _ in tqdm(range(75)):
    tt = defaultdict(int)
    for i, j in t.items():
        length = get_length(i)
        if i == 0:
            tt[1] += j
        elif length % 2 == 0:
            tt[i // 10 ** (length // 2)] += j
            tt[i % 10 ** (length // 2)] += j
        else:
            tt[i * 2024] += j
        
        t = tt

print(sum(t.values()))
```

</p>
</details> 

> `tqdm` 是为了监控速度, 非必要引入
> 与第一题不同, 这题指数爆炸, 75次会超时, 因为答案不要求顺序, 所以可以用缓存

## 第十二题

[https://adventofcode.com/2024/day/12](https://adventofcode.com/2024/day/12)

### 1题

划分区域

```text
AAAA
BBCD
BBCC
EEEC
```

划分成

```text
+-+-+-+-+
|A A A A|
+-+-+-+-+     +-+
              |D|
+-+-+   +-+   +-+
|B B|   |C|
+   +   + +-+
|B B|   |C C|
+-+-+   +-+ +
          |C|
+-+-+-+   +-+
|E E E|
+-+-+-+
```

分为五个区域, 
计算每个区域的周长*面积之和

<details><summary>Details</summary>
<p>

```python

aa = []
for i in a.splitlines():
    aa.append(list(i))

def get_perimeter(arr):
    perimeter = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                perimeter += 4
                if i > 0 and arr[i - 1][j] == 1:
                    perimeter -= 1
                if j > 0 and arr[i][j - 1] == 1:
                    perimeter -= 1
                if i < len(arr) - 1 and arr[i + 1][j] == 1:
                    perimeter -= 1
                if j < len(arr[0]) - 1 and arr[i][j + 1] == 1:
                    perimeter -= 1
    
    return perimeter

def get_area(arr):
    area = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                area += 1
    return area

def get_allow_pos(pos):
    allow_pos = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    char = aa[pos[0]][pos[1]]
    for i in allow_pos:
        next_pos = (pos[0] + i[0], pos[1] + i[1])
        if len(aa) > next_pos[0] >= 0 and len(aa[0]) > next_pos[1] >= 0:
            if aa[next_pos[0]][next_pos[1]] == char:
                yield next_pos


ans = 0

already_visited = np.zeros((len(aa), len(aa[0])))
for i in range(len(aa)):
    for j in range(len(aa[i])):
        if already_visited[i][j] == 0:
            # print(aa[i][j])
            array_ = np.zeros((len(aa), len(aa[0])))
            already_visited[i][j] = 1
            array_[i][j] = 1
            def dfs(pos):
                for next_pos in get_allow_pos(pos):
                    if already_visited[next_pos[0]][next_pos[1]] == 0:
                        already_visited[next_pos[0]][next_pos[1]] = 1
                        array_[next_pos[0]][next_pos[1]] = 1
                        dfs(next_pos)
            
            dfs((i, j))
            area = get_area(array_)
            perimeter = get_perimeter(array_)
            ans += area * perimeter
        
print(ans)

```

</p>
</details> 

> 加一个正方形边长+4, 如果旁边每有一个正方形就-1的边长

### 2题

1题的边长变成边的数量

<details><summary>Details</summary>
<p>

```python

aa = []
for i in a.splitlines():
    aa.append(list(i))



def get_area(arr):
    area = 0
    for i in range(len(arr)):
        for j in range(len(arr[0])):
            if arr[i][j] == 1:
                area += 1
    return area

def get_perimeter(region):
        
    max_x = len(region) - 1
    max_y = len(region[0]) - 1
    min_x = min_y = 0
    
    def state(x, y):
        if x < 0 or x > max_x or y < 0 or y > max_y:
            return False
        return region[x][y]
    
    perimeter = 0
    
    # 垂直方向扫描
    for i in range(max_x + 1):
        st = state(i, -1)
        for j in range(max_y + 2):
            if st != state(i, j):
                if st != state(i-1, j-1) or st == state(i-1, j):
                    perimeter += 1
                if st != state(i+1, j-1) or st == state(i+1, j):
                    perimeter += 1
                st = not st
    
    # 水平方向扫描
    for j in range(max_y + 1):
        st = state(-1, j)
        for i in range(max_x + 2):
            if st != state(i, j):
                if st != state(i-1, j-1) or st == state(i, j-1):
                    perimeter += 1
                if st != state(i-1, j+1) or st == state(i, j+1):
                    perimeter += 1
                st = not st
    
    return perimeter // 2

def get_allow_pos(pos):
    allow_pos = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    char = aa[pos[0]][pos[1]]
    for i in allow_pos:
        next_pos = (pos[0] + i[0], pos[1] + i[1])
        if len(aa) > next_pos[0] >= 0 and len(aa[0]) > next_pos[1] >= 0:
            if aa[next_pos[0]][next_pos[1]] == char:
                yield next_pos

ans = 0

already_visited = np.zeros((len(aa), len(aa[0])))
for i in range(len(aa)):
    for j in range(len(aa[i])):
        if already_visited[i][j] == 0:
            # print(aa[i][j])
            array_ = np.zeros((len(aa), len(aa[0])))
            already_visited[i][j] = 1
            array_[i][j] = 1
            def dfs(pos):
                for next_pos in get_allow_pos(pos):
                    if already_visited[next_pos[0]][next_pos[1]] == 0:
                        already_visited[next_pos[0]][next_pos[1]] = 1
                        array_[next_pos[0]][next_pos[1]] = 1
                        
                        dfs(next_pos)
            
            dfs((i, j))
            area = get_area(array_)
            perimeter = get_perimeter(array_)
            # print(perimeter)
            ans += area * perimeter
        
print(ans)

```

</p>
</details> 

> 一条边有两个角, 找到所有角之后整除2即可

## 第十三题

[https://adventofcode.com/2024/day/13](https://adventofcode.com/2024/day/13)

### 1题

按下按钮A或B, 移动老虎爪, 让老虎爪移动到指定的位置, 按下A需要三块钱, B需要一块钱
有可能无解(无法移动到指定位置)

<details><summary>Details</summary>
<p>

```python

aa = a.split('\n\n')
from sympy import *

ans = 0
for i in aa:
    inputs = i.split('\n')
    # 提取输入
    ax, ay = inputs[0].split(': ')[1].split(', ')
    bx, by = inputs[1].split(': ')[1].split(', ')
    t1, t2 = inputs[2].split(': ')[1].split(', ')
    ax, ay = int(ax[2:]), int(ay[2:])
    bx, by = int(bx[2:]), int(by[2:])
    t1, t2 = int(t1[2:]), int(t2[2:])
    m = Symbol('m')
    n = Symbol('n')
    temp = solve([m * ax + n * bx - t1, m * ay + n * by - t2], [m, n])
    # print(temp)
    if temp[m].is_Integer and temp[n].is_Integer:
        ans += int(temp[m]) * 3 + int(temp[n])

print(ans)

```

</p>
</details> 
> 二元一次方程组的整数解

### 2题

在一题的基础上, X轴和Y轴上都高出10000000000000(大数)

<details><summary>Details</summary>
<p>

```python

aa = a.split('\n\n')
from sympy import *

ans = 0
for i in aa:
    inputs = i.split('\n')
    # 提取输入
    ax, ay = inputs[0].split(': ')[1].split(', ')
    bx, by = inputs[1].split(': ')[1].split(', ')
    t1, t2 = inputs[2].split(': ')[1].split(', ')
    ax, ay = int(ax[2:]), int(ay[2:])
    bx, by = int(bx[2:]), int(by[2:])
    t1, t2 = int(t1[2:]) + 10000000000000, int(t2[2:]) + 10000000000000
    m = Symbol('m')
    n = Symbol('n')
    temp = solve([m * ax + n * bx - t1, m * ay + n * by - t2], [m, n])
    # print(temp)
    if temp[m].is_Integer and temp[n].is_Integer:
        ans += int(temp[m]) * 3 + int(temp[n])

print(ans)
```

</p>
</details> 

> python无限精度整数, 不需要额外处理

## 第十四题

[https://adventofcode.com/2024/day/14](https://adventofcode.com/2024/day/14)

### 1题

给定点坐标, 点的移动速度, 大小固定的图

求 四个象限内点的数量 之积
象限是去掉最中间一列与一行使得图分成四个区域
点到边界会传送到另一侧 (mod)

<details><summary>Details</summary>
<p>

```python

def main():
    lines = a.splitlines()

    robots = []
    for line in lines:
        p_part, v_part = line.strip().split()
        p_x, p_y = map(int, p_part[2:].split(','))
        v_x, v_y = map(int, v_part[2:].split(','))
        robots.append({'p': (p_x, p_y), 'v': (v_x, v_y)})

    positions = {}
    for robot in robots:
        x = (robot['p'][0] + robot['v'][0] * 100) % 101
        y = (robot['p'][1] + robot['v'][1] * 100) % 103
        positions[(x, y)] = positions.get((x, y), 0) + 1

    q1 = q2 = q3 = q4 = 0
    for (x, y), count in positions.items():
        if x < 50 and y < 51:
            q1 += count
        elif x > 50 and y < 51:
            q2 += count
        elif x > 50 and y > 51:
            q3 += count
        elif x < 50 and y > 51:
            q4 += count

    safety_factor = q1 * q2 * q3 * q4
    print(safety_factor)

if __name__ == '__main__':
    main()

```

</p>
</details> 

### 2题

直接贴原题, 因为原题是阅读理解

During the bathroom break, someone notices that these robots seem awfully similar to ones built and used at the North Pole. If they're the same type of robots, they should have a hard-coded Easter egg: very rarely, most of the robots should arrange themselves into a picture of a Christmas tree.
> 在上厕所的时候，有人注意到这些机器人看起来与在北极建造和使用的机器人非常相似。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://FairyOwO.github.io/post/2024%20Advent%20of%20Code%20-fu-pan-yu-da-an-%20%28-er-%29%20%289-16-ti-%29.html">
<meta property="og:image" content="https://github.githubassets.com/favicons/favicon.svg">
<title>2024 Advent of Code 复盘与答案 (二) (9-16题)</title>
<link href="//unpkg.com/@wooorm/starry-night@2.1.1/style/both.css" rel="stylesheet" />


</head>
<style>
body{box-sizing: border-box;min-width: 200px;max-width: 900px;margin: 20px auto;padding: 45px;font-size: 16px;font-family: sans-serif;line-height: 1.25;}
#header{display:flex;padding-bottom:8px;border-bottom: 1px solid var(--borderColor-muted, var(--color-border-muted));margin-bottom: 16px;}
#footer {margin-top:64px; text-align: center;font-size: small;}

</style>

<style>
.postTitle{margin: auto 0;font-size:40px;font-weight:bold;}
.title-right{display:flex;margin:auto 0 0 auto;}
.title-right .circle{padding: 14px 16px;margin-right:8px;}
#postBody{border-bottom: 1px solid var(--color-border-default);padding-bottom:36px;}
#postBody hr{height:2px;}
#cmButton{height:48px;margin-top:48px;}
#comments{margin-top:64px;}
.g-emoji{font-size:24px;}
@media (max-width: 600px) {
    body {padding: 8px;}
    .postTitle{font-size:24px;}
}
.copy-feedback {
    display: none;
    position: absolute;
    top: 10px;
    right: 50px;
    color: var(--color-fg-on-emphasis);
    background-color: var(--color-fg-muted);
    border-radius: 3px;
    padding: 5px 8px;
    font-size: 12px;
}
</style>




<body>
    <div id="header">
<h1 class="postTitle">2024 Advent of Code 复盘与答案 (二) (9-16题)</h1>
<div class="title-right">
    <a href="https://FairyOwO.github.io" id="buttonHome" class="btn btn-invisible circle" title="首页">
        <svg class="octicon" width="16" height="16">
            <path id="pathHome" fill-rule="evenodd"></path>
        </svg>
    </a>
    
    <a href="https://github.com/FairyOwO/FairyOwO.github.io/issues/8" target="_blank" class="btn btn-invisible circle" title="Issue">
        <svg class="octicon" width="16" height="16">
            <path id="pathIssue" fill-rule="evenodd"></path>
        </svg>
    </a>
    

    <a class="btn btn-invisible circle" onclick="modeSwitch();" title="切换主题">
        <svg class="octicon" width="16" height="16" >
            <path id="themeSwitch" fill-rule="evenodd"></path>
        </svg>
    </a>

</div>
</div>
    <div id="content">
<div class="markdown-body" id="postBody"><p><a href="https://adventofcode.com/" rel="nofollow">Advent of Code</a></p>
<p>使用 python 编写, 没有整理代码, 所以非常乱(变量乱取名, 没有注释, 逻辑奇怪, 并非最佳实现)<br>
可以使用 gpt 相关工具辅助查看</p>
<blockquote>
<p>如果没有特意说明, 变量 a 统一存放所有原始字符串</p>
</blockquote>
<h2>第九题</h2>
<p><a href="https://adventofcode.com/2024/day/9" rel="nofollow">https://adventofcode.com/2024/day/9</a></p>
<h3>1题</h3>
<p>一个磁盘中的文件表示方法, 每两位数字各表示, x块文件, x块空的区域<br>
例如<br>
<code class="notranslate">12345</code><br>
表示 一块文件 两块空文件 三块文件 四块空文件 五块文件<br>
每个文件从前往后的id为他们在磁盘中的顺序, 例如上述可以表示为<br>
<code class="notranslate">0..111....22222</code></p>
<p>希望从后往前的将文件塞入从前往后中空的地方</p>
<p>例如</p>
<pre lang="text" class="notranslate"><code class="notranslate">0..111....22222
02.111....2222.
022111....222..
0221112...22...
02211122..2....
022111222......
</code></pre>
<p>最后输出每个块位置*id号之和</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-c"># 构建</span>
<span class="pl-s1">t</span> <span class="pl-c1">=</span> []
<span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">True</span>
<span class="pl-s1">file_id</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">list</span>(<span class="pl-s1">a</span>):
    <span class="pl-k">if</span> <span class="pl-s1">flag</span>:
        <span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">int</span>(<span class="pl-s1">i</span>)):
            <span class="pl-s1">t</span>.<span class="pl-c1">append</span>(<span class="pl-s1">file_id</span>)
        <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">False</span>
        <span class="pl-s1">file_id</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>:
        <span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">int</span>(<span class="pl-s1">i</span>)):
            <span class="pl-s1">t</span>.<span class="pl-c1">append</span>(<span class="pl-s">'.'</span>)
        <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">True</span>

<span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-s1">j</span> <span class="pl-c1">=</span> <span class="pl-en">len</span>(<span class="pl-s1">t</span>) <span class="pl-c1">-</span> <span class="pl-c1">1</span>

<span class="pl-k">while</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">j</span>:
    <span class="pl-k">if</span> <span class="pl-s1">t</span>[<span class="pl-s1">i</span>] <span class="pl-c1">==</span> <span class="pl-s">'.'</span>:
        <span class="pl-k">if</span> <span class="pl-s1">t</span>[<span class="pl-s1">j</span>] <span class="pl-c1">!=</span> <span class="pl-s">'.'</span>:
            <span class="pl-s1">t</span>[<span class="pl-s1">i</span>], <span class="pl-s1">t</span>[<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-s1">t</span>[<span class="pl-s1">j</span>], <span class="pl-s1">t</span>[<span class="pl-s1">i</span>]
        <span class="pl-k">else</span>:
            <span class="pl-s1">i</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
        <span class="pl-s1">j</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
    <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">t</span>):
    <span class="pl-k">if</span> <span class="pl-s1">j</span> <span class="pl-c1">!=</span> <span class="pl-s">'.'</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-s1">i</span> <span class="pl-c1">*</span> <span class="pl-s1">j</span>
<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<h3>2题</h3>
<p>在一题的基础上, 修改从后往前放入从前往后空区域的方法, 从单个块移动转换为整个文件移动, 例如</p>
<pre lang="text" class="notranslate"><code class="notranslate">00...111...2...333.44.5555.6666.777.888899
0099.111...2...333.44.5555.6666.777.8888..
0099.1117772...333.44.5555.6666.....8888..
0099.111777244.333....5555.6666.....8888..
00992111777.44.333....5555.6666.....8888..
</code></pre>
<p>最后输出每个块位置*id号之和</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-c"># 构建</span>
<span class="pl-s1">t</span> <span class="pl-c1">=</span> []
<span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">True</span>
<span class="pl-s1">file_id</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">list</span>(<span class="pl-s1">a</span>):
    <span class="pl-k">if</span> <span class="pl-s1">flag</span>:
        <span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">int</span>(<span class="pl-s1">i</span>)):
            <span class="pl-s1">t</span>.<span class="pl-c1">append</span>(<span class="pl-s1">file_id</span>)
        <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">False</span>
        <span class="pl-s1">file_id</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">else</span>:
        <span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">int</span>(<span class="pl-s1">i</span>)):
            <span class="pl-s1">t</span>.<span class="pl-c1">append</span>(<span class="pl-s">'.'</span>)
        <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">True</span>


<span class="pl-k">def</span> <span class="pl-en">get_file_size</span>(<span class="pl-s1">file_id</span>):
    <span class="pl-k">return</span> <span class="pl-s1">t</span>.<span class="pl-c1">count</span>(<span class="pl-s1">file_id</span>)

<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">file_id</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>):
    <span class="pl-s1">file_size</span> <span class="pl-c1">=</span> <span class="pl-en">get_file_size</span>(<span class="pl-s1">i</span>)
    <span class="pl-s1">file_index</span> <span class="pl-c1">=</span> <span class="pl-s1">t</span>.<span class="pl-c1">index</span>(<span class="pl-s1">i</span>)
    <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">False</span>
    <span class="pl-s1">size</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">id</span>, <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">t</span>):
        <span class="pl-k">if</span> <span class="pl-s1">j</span> <span class="pl-c1">==</span> <span class="pl-s">'.'</span>:
            <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">True</span>
        <span class="pl-k">else</span>:
            <span class="pl-s1">flag</span> <span class="pl-c1">=</span> <span class="pl-c1">False</span>
            <span class="pl-s1">size</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
        
        <span class="pl-k">if</span> <span class="pl-s1">flag</span>:
            <span class="pl-s1">size</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
            <span class="pl-k">if</span> <span class="pl-s1">size</span> <span class="pl-c1">==</span> <span class="pl-s1">file_size</span>:
                <span class="pl-c"># change位置</span>
                <span class="pl-k">for</span> <span class="pl-s1">k</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">id</span>, <span class="pl-s1">id</span> <span class="pl-c1">-</span> <span class="pl-s1">file_size</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>):
                    <span class="pl-s1">t</span>[<span class="pl-s1">k</span>], <span class="pl-s1">t</span>[<span class="pl-s1">file_index</span>] <span class="pl-c1">=</span> <span class="pl-s1">t</span>[<span class="pl-s1">file_index</span>], <span class="pl-s1">t</span>[<span class="pl-s1">k</span>]
                    <span class="pl-s1">file_index</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>

                <span class="pl-k">break</span>
        <span class="pl-k">if</span> <span class="pl-s1">id</span> <span class="pl-c1">&gt;=</span> <span class="pl-s1">file_index</span>:
            <span class="pl-k">break</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">t</span>):
    <span class="pl-k">if</span> <span class="pl-s1">j</span> <span class="pl-c1">!=</span> <span class="pl-s">'.'</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-s1">i</span> <span class="pl-c1">*</span> <span class="pl-s1">j</span>
<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<h2>第十题</h2>
<p><a href="https://adventofcode.com/2024/day/10" rel="nofollow">https://adventofcode.com/2024/day/10</a></p>
<h3>1题</h3>
<p>给定一幅由数字组成的地图, 从 0 开始, 一步一步上下左右移动到 9<br>
求一副图中, 每一个 0 能到达的 9 有多少个, 输出他们的和</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aaa</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>():
    <span class="pl-s1">aaa</span>.<span class="pl-c1">append</span>(<span class="pl-en">list</span>(<span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-en">list</span>(<span class="pl-s1">i</span>))))

<span class="pl-c"># print(aaa)</span>

<span class="pl-c"># 获取所有 0 跟 9 的位置</span>
<span class="pl-s1">pos_0</span> <span class="pl-c1">=</span> []
<span class="pl-s1">pos_9</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aaa</span>)):
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>])):
        <span class="pl-k">if</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-s1">pos_0</span>.<span class="pl-c1">append</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))
        <span class="pl-k">elif</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">9</span>:
            <span class="pl-s1">pos_9</span>.<span class="pl-c1">append</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))

<span class="pl-k">def</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> [(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>)]:
        <span class="pl-s1">next_step</span> <span class="pl-c1">=</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])
        <span class="pl-k">if</span> <span class="pl-en">len</span>(<span class="pl-s1">aaa</span>) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_step</span>[<span class="pl-c1">0</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-en">len</span>(<span class="pl-s1">aaa</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_step</span>[<span class="pl-c1">1</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span>:
            <span class="pl-k">if</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">next_step</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_step</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">+</span> <span class="pl-c1">1</span>:
                <span class="pl-k">yield</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])


<span class="pl-k">def</span> <span class="pl-en">dfs</span>(<span class="pl-s1">pos</span>, <span class="pl-s1">pos_9</span>):
    <span class="pl-k">if</span> <span class="pl-s1">pos</span> <span class="pl-c1">==</span> <span class="pl-s1">pos_9</span>:
        <span class="pl-k">return</span> <span class="pl-c1">1</span>
    <span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">p</span> <span class="pl-c1">in</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
        <span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-en">dfs</span>(<span class="pl-s1">p</span>, <span class="pl-s1">pos_9</span>)
        <span class="pl-k">if</span> <span class="pl-s1">aa</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> <span class="pl-s1">aa</span>
    <span class="pl-k">return</span> <span class="pl-s1">aa</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">pos_0</span>:
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-s1">pos_9</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-en">dfs</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span>)

<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<h3>2题</h3>
<p>求 0 到每一个 9 有多少种不同的走法 (注意与第一题的区别, 第一题只要求到达, 第二题需要找到所有路线)</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aaa</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>():
    <span class="pl-s1">aaa</span>.<span class="pl-c1">append</span>(<span class="pl-en">list</span>(<span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-en">list</span>(<span class="pl-s1">i</span>))))

<span class="pl-c"># print(aaa)</span>

<span class="pl-c"># 获取所有 0 跟 9 的位置</span>
<span class="pl-s1">pos_0</span> <span class="pl-c1">=</span> []
<span class="pl-s1">pos_9</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aaa</span>)):
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>])):
        <span class="pl-k">if</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-s1">pos_0</span>.<span class="pl-c1">append</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))
        <span class="pl-k">elif</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">9</span>:
            <span class="pl-s1">pos_9</span>.<span class="pl-c1">append</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))

<span class="pl-k">def</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> [(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>)]:
        <span class="pl-s1">next_step</span> <span class="pl-c1">=</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])
        <span class="pl-k">if</span> <span class="pl-en">len</span>(<span class="pl-s1">aaa</span>) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_step</span>[<span class="pl-c1">0</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-en">len</span>(<span class="pl-s1">aaa</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_step</span>[<span class="pl-c1">1</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span>:
            <span class="pl-k">if</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">next_step</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_step</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-s1">aaa</span>[<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">+</span> <span class="pl-c1">1</span>:
                <span class="pl-k">yield</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])


<span class="pl-k">def</span> <span class="pl-en">dfs</span>(<span class="pl-s1">pos</span>, <span class="pl-s1">pos_9</span>):
    <span class="pl-k">if</span> <span class="pl-s1">pos</span> <span class="pl-c1">==</span> <span class="pl-s1">pos_9</span>:
        <span class="pl-k">return</span> <span class="pl-c1">1</span>
    <span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">p</span> <span class="pl-c1">in</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
        <span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-en">dfs</span>(<span class="pl-s1">p</span>, <span class="pl-s1">pos_9</span>)
        <span class="pl-k">if</span> <span class="pl-s1">aa</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> <span class="pl-s1">aa</span>
    <span class="pl-k">return</span> <span class="pl-s1">aa</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">pos_0</span>:
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-s1">pos_9</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-en">dfs</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span>)

<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<blockquote>
<p>在一题的基础上, dfs固定返回1 变成 dfs 返回上一次dfs + 1</p>
</blockquote>
<h2>第十一题</h2>
<p><a href="https://adventofcode.com/2024/day/11" rel="nofollow">https://adventofcode.com/2024/day/11</a></p>
<h3>1题</h3>
<p>给定一串数字, 根据以下规则变换</p>
<ol>
<li>如果数字是0, 则数字是1</li>
<li>如果数字是偶数位, 则数字变成两个数字, 左半跟右半, 例如 1000 变成 10 跟 00, 不保留前导0, 00变成0</li>
<li>如果没有碰到前两条规则, 则数字=数字*2024</li>
</ol>
<p>顺序都会被保留 (但是这题没有用到, 而且会误导第二题)<br>
模拟上述规则25次</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">split</span>(<span class="pl-s">' '</span>)

<span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-c1">25</span>):
    <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>):
        <span class="pl-k">if</span> <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>] <span class="pl-c1">==</span> <span class="pl-s">'0'</span>:
            <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s">'1'</span>
        <span class="pl-k">elif</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>]) <span class="pl-c1">%</span> <span class="pl-c1">2</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-s1">left</span> <span class="pl-c1">=</span> <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>][:<span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>]) <span class="pl-c1">//</span> <span class="pl-c1">2</span>]
            <span class="pl-s1">left</span> <span class="pl-c1">=</span> <span class="pl-en">str</span>(<span class="pl-en">int</span>(<span class="pl-s1">left</span>))
            <span class="pl-s1">right</span> <span class="pl-c1">=</span> <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>][<span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>]) <span class="pl-c1">//</span> <span class="pl-c1">2</span>:]
            <span class="pl-s1">right</span> <span class="pl-c1">=</span> <span class="pl-en">str</span>(<span class="pl-en">int</span>(<span class="pl-s1">right</span>))
            <span class="pl-s1">aa</span>.<span class="pl-c1">insert</span>(<span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>, <span class="pl-s1">right</span>)
            <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-s1">left</span>
            <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
        <span class="pl-k">else</span>:
            <span class="pl-s1">aa</span>[<span class="pl-s1">i</span>] <span class="pl-c1">=</span> <span class="pl-en">str</span>(<span class="pl-en">int</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>]) <span class="pl-c1">*</span> <span class="pl-c1">2024</span>)
        
        <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>

<span class="pl-en">print</span>(<span class="pl-en">len</span>(<span class="pl-s1">aa</span>))</pre></div>
<p></p>
</details> 
<blockquote>
<p>模拟即可, 25次蛮少的可以直接出来</p>
</blockquote>
<h3>2题</h3>
<p>在1题的基础上, 模拟75次</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">from</span> <span class="pl-s1">collections</span> <span class="pl-k">import</span> <span class="pl-s1">defaultdict</span>
<span class="pl-k">from</span> <span class="pl-s1">tqdm</span> <span class="pl-k">import</span> <span class="pl-s1">tqdm</span>
<span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-en">list</span>(<span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-s1">a</span>.<span class="pl-c1">split</span>(<span class="pl-s">' '</span>)))

<span class="pl-k">def</span> <span class="pl-en">get_length</span>(<span class="pl-s1">num</span>):
    <span class="pl-s1">i</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> <span class="pl-s1">num</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span>:
        <span class="pl-s1">num</span> <span class="pl-c1">//=</span> <span class="pl-c1">10</span>
        <span class="pl-s1">i</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">return</span> <span class="pl-s1">i</span>

<span class="pl-s1">t</span> <span class="pl-c1">=</span> <span class="pl-en">defaultdict</span>(<span class="pl-s1">int</span>)

<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">aa</span>:
    <span class="pl-s1">t</span>[<span class="pl-s1">i</span>] <span class="pl-c1">+=</span> <span class="pl-c1">1</span>

<span class="pl-k">for</span> <span class="pl-s1">_</span> <span class="pl-c1">in</span> <span class="pl-en">tqdm</span>(<span class="pl-en">range</span>(<span class="pl-c1">75</span>)):
    <span class="pl-s1">tt</span> <span class="pl-c1">=</span> <span class="pl-en">defaultdict</span>(<span class="pl-s1">int</span>)
    <span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-s1">t</span>.<span class="pl-c1">items</span>():
        <span class="pl-s1">length</span> <span class="pl-c1">=</span> <span class="pl-en">get_length</span>(<span class="pl-s1">i</span>)
        <span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-s1">tt</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+=</span> <span class="pl-s1">j</span>
        <span class="pl-k">elif</span> <span class="pl-s1">length</span> <span class="pl-c1">%</span> <span class="pl-c1">2</span> <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-s1">tt</span>[<span class="pl-s1">i</span> <span class="pl-c1">//</span> <span class="pl-c1">10</span> <span class="pl-c1">**</span> (<span class="pl-s1">length</span> <span class="pl-c1">//</span> <span class="pl-c1">2</span>)] <span class="pl-c1">+=</span> <span class="pl-s1">j</span>
            <span class="pl-s1">tt</span>[<span class="pl-s1">i</span> <span class="pl-c1">%</span> <span class="pl-c1">10</span> <span class="pl-c1">**</span> (<span class="pl-s1">length</span> <span class="pl-c1">//</span> <span class="pl-c1">2</span>)] <span class="pl-c1">+=</span> <span class="pl-s1">j</span>
        <span class="pl-k">else</span>:
            <span class="pl-s1">tt</span>[<span class="pl-s1">i</span> <span class="pl-c1">*</span> <span class="pl-c1">2024</span>] <span class="pl-c1">+=</span> <span class="pl-s1">j</span>
        
        <span class="pl-s1">t</span> <span class="pl-c1">=</span> <span class="pl-s1">tt</span>

<span class="pl-en">print</span>(<span class="pl-en">sum</span>(<span class="pl-s1">t</span>.<span class="pl-c1">values</span>()))</pre></div>
<p></p>
</details> 
<blockquote>
<p><code class="notranslate">tqdm</code> 是为了监控速度, 非必要引入<br>
与第一题不同, 这题指数爆炸, 75次会超时, 因为答案不要求顺序, 所以可以用缓存</p>
</blockquote>
<h2>第十二题</h2>
<p><a href="https://adventofcode.com/2024/day/12" rel="nofollow">https://adventofcode.com/2024/day/12</a></p>
<h3>1题</h3>
<p>划分区域</p>
<pre lang="text" class="notranslate"><code class="notranslate">AAAA
BBCD
BBCC
EEEC
</code></pre>
<p>划分成</p>
<pre lang="text" class="notranslate"><code class="notranslate">+-+-+-+-+
|A A A A|
+-+-+-+-+     +-+
              |D|
+-+-+   +-+   +-+
|B B|   |C|
+   +   + +-+
|B B|   |C C|
+-+-+   +-+ +
          |C|
+-+-+-+   +-+
|E E E|
+-+-+-+
</code></pre>
<p>分为五个区域,<br>
计算每个区域的周长*面积之和</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aa</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>():
    <span class="pl-s1">aa</span>.<span class="pl-c1">append</span>(<span class="pl-en">list</span>(<span class="pl-s1">i</span>))

<span class="pl-k">def</span> <span class="pl-en">get_perimeter</span>(<span class="pl-s1">arr</span>):
    <span class="pl-s1">perimeter</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>)):
        <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>[<span class="pl-c1">0</span>])):
            <span class="pl-k">if</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                <span class="pl-s1">perimeter</span> <span class="pl-c1">+=</span> <span class="pl-c1">4</span>
                <span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
                <span class="pl-k">if</span> <span class="pl-s1">j</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
                <span class="pl-k">if</span> <span class="pl-s1">i</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">arr</span>) <span class="pl-c1">-</span> <span class="pl-c1">1</span> <span class="pl-c1">and</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
                <span class="pl-k">if</span> <span class="pl-s1">j</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">arr</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">-</span> <span class="pl-c1">1</span> <span class="pl-c1">and</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">-=</span> <span class="pl-c1">1</span>
    
    <span class="pl-k">return</span> <span class="pl-s1">perimeter</span>

<span class="pl-k">def</span> <span class="pl-en">get_area</span>(<span class="pl-s1">arr</span>):
    <span class="pl-s1">area</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>)):
        <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>[<span class="pl-c1">0</span>])):
            <span class="pl-k">if</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                <span class="pl-s1">area</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">return</span> <span class="pl-s1">area</span>

<span class="pl-k">def</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
    <span class="pl-s1">allow_pos</span> <span class="pl-c1">=</span> [(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>)]
    <span class="pl-s1">char</span> <span class="pl-c1">=</span> <span class="pl-s1">aa</span>[<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">pos</span>[<span class="pl-c1">1</span>]]
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">allow_pos</span>:
        <span class="pl-s1">next_pos</span> <span class="pl-c1">=</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])
        <span class="pl-k">if</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span>:
            <span class="pl-k">if</span> <span class="pl-s1">aa</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-s1">char</span>:
                <span class="pl-k">yield</span> <span class="pl-s1">next_pos</span>


<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>

<span class="pl-s1">already_visited</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">zeros</span>((<span class="pl-en">len</span>(<span class="pl-s1">aa</span>), <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>])))
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aa</span>)):
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>])):
        <span class="pl-k">if</span> <span class="pl-s1">already_visited</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-c"># print(aa[i][j])</span>
            <span class="pl-s1">array_</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">zeros</span>((<span class="pl-en">len</span>(<span class="pl-s1">aa</span>), <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>])))
            <span class="pl-s1">already_visited</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
            <span class="pl-s1">array_</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
            <span class="pl-k">def</span> <span class="pl-en">dfs</span>(<span class="pl-s1">pos</span>):
                <span class="pl-k">for</span> <span class="pl-s1">next_pos</span> <span class="pl-c1">in</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
                    <span class="pl-k">if</span> <span class="pl-s1">already_visited</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
                        <span class="pl-s1">already_visited</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                        <span class="pl-s1">array_</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                        <span class="pl-en">dfs</span>(<span class="pl-s1">next_pos</span>)
            
            <span class="pl-en">dfs</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))
            <span class="pl-s1">area</span> <span class="pl-c1">=</span> <span class="pl-en">get_area</span>(<span class="pl-s1">array_</span>)
            <span class="pl-s1">perimeter</span> <span class="pl-c1">=</span> <span class="pl-en">get_perimeter</span>(<span class="pl-s1">array_</span>)
            <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-s1">area</span> <span class="pl-c1">*</span> <span class="pl-s1">perimeter</span>
        
<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<blockquote>
<p>加一个正方形边长+4, 如果旁边每有一个正方形就-1的边长</p>
</blockquote>
<h3>2题</h3>
<p>1题的边长变成边的数量</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aa</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>():
    <span class="pl-s1">aa</span>.<span class="pl-c1">append</span>(<span class="pl-en">list</span>(<span class="pl-s1">i</span>))



<span class="pl-k">def</span> <span class="pl-en">get_area</span>(<span class="pl-s1">arr</span>):
    <span class="pl-s1">area</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>)):
        <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">arr</span>[<span class="pl-c1">0</span>])):
            <span class="pl-k">if</span> <span class="pl-s1">arr</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">1</span>:
                <span class="pl-s1">area</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
    <span class="pl-k">return</span> <span class="pl-s1">area</span>

<span class="pl-k">def</span> <span class="pl-en">get_perimeter</span>(<span class="pl-s1">region</span>):
        
    <span class="pl-s1">max_x</span> <span class="pl-c1">=</span> <span class="pl-en">len</span>(<span class="pl-s1">region</span>) <span class="pl-c1">-</span> <span class="pl-c1">1</span>
    <span class="pl-s1">max_y</span> <span class="pl-c1">=</span> <span class="pl-en">len</span>(<span class="pl-s1">region</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">-</span> <span class="pl-c1">1</span>
    <span class="pl-s1">min_x</span> <span class="pl-c1">=</span> <span class="pl-s1">min_y</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    
    <span class="pl-k">def</span> <span class="pl-en">state</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>):
        <span class="pl-k">if</span> <span class="pl-s1">x</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> <span class="pl-c1">or</span> <span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">max_x</span> <span class="pl-c1">or</span> <span class="pl-s1">y</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">0</span> <span class="pl-c1">or</span> <span class="pl-s1">y</span> <span class="pl-c1">&gt;</span> <span class="pl-s1">max_y</span>:
            <span class="pl-k">return</span> <span class="pl-c1">False</span>
        <span class="pl-k">return</span> <span class="pl-s1">region</span>[<span class="pl-s1">x</span>][<span class="pl-s1">y</span>]
    
    <span class="pl-s1">perimeter</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    
    <span class="pl-c"># 垂直方向扫描</span>
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">max_x</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>):
        <span class="pl-s1">st</span> <span class="pl-c1">=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>)
        <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">max_y</span> <span class="pl-c1">+</span> <span class="pl-c1">2</span>):
            <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span>):
                <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span><span class="pl-c1">-</span><span class="pl-c1">1</span>) <span class="pl-c1">or</span> <span class="pl-s1">st</span> <span class="pl-c1">==</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span>):
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
                <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span><span class="pl-c1">-</span><span class="pl-c1">1</span>) <span class="pl-c1">or</span> <span class="pl-s1">st</span> <span class="pl-c1">==</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">+</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span>):
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
                <span class="pl-s1">st</span> <span class="pl-c1">=</span> <span class="pl-c1">not</span> <span class="pl-s1">st</span>
    
    <span class="pl-c"># 水平方向扫描</span>
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">max_y</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>):
        <span class="pl-s1">st</span> <span class="pl-c1">=</span> <span class="pl-en">state</span>(<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span>)
        <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-s1">max_x</span> <span class="pl-c1">+</span> <span class="pl-c1">2</span>):
            <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span>):
                <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span><span class="pl-c1">-</span><span class="pl-c1">1</span>) <span class="pl-c1">or</span> <span class="pl-s1">st</span> <span class="pl-c1">==</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span><span class="pl-c1">-</span><span class="pl-c1">1</span>):
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
                <span class="pl-k">if</span> <span class="pl-s1">st</span> <span class="pl-c1">!=</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span><span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-s1">j</span><span class="pl-c1">+</span><span class="pl-c1">1</span>) <span class="pl-c1">or</span> <span class="pl-s1">st</span> <span class="pl-c1">==</span> <span class="pl-en">state</span>(<span class="pl-s1">i</span>, <span class="pl-s1">j</span><span class="pl-c1">+</span><span class="pl-c1">1</span>):
                    <span class="pl-s1">perimeter</span> <span class="pl-c1">+=</span> <span class="pl-c1">1</span>
                <span class="pl-s1">st</span> <span class="pl-c1">=</span> <span class="pl-c1">not</span> <span class="pl-s1">st</span>
    
    <span class="pl-k">return</span> <span class="pl-s1">perimeter</span> <span class="pl-c1">//</span> <span class="pl-c1">2</span>

<span class="pl-k">def</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
    <span class="pl-s1">allow_pos</span> <span class="pl-c1">=</span> [(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">1</span>), (<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>), (<span class="pl-c1">0</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>)]
    <span class="pl-s1">char</span> <span class="pl-c1">=</span> <span class="pl-s1">aa</span>[<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">pos</span>[<span class="pl-c1">1</span>]]
    <span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">allow_pos</span>:
        <span class="pl-s1">next_pos</span> <span class="pl-c1">=</span> (<span class="pl-s1">pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">0</span>], <span class="pl-s1">pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">i</span>[<span class="pl-c1">1</span>])
        <span class="pl-k">if</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span> <span class="pl-c1">and</span> <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">&gt;</span> <span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>] <span class="pl-c1">&gt;=</span> <span class="pl-c1">0</span>:
            <span class="pl-k">if</span> <span class="pl-s1">aa</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-s1">char</span>:
                <span class="pl-k">yield</span> <span class="pl-s1">next_pos</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>

<span class="pl-s1">already_visited</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">zeros</span>((<span class="pl-en">len</span>(<span class="pl-s1">aa</span>), <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>])))
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aa</span>)):
    <span class="pl-k">for</span> <span class="pl-s1">j</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-s1">i</span>])):
        <span class="pl-k">if</span> <span class="pl-s1">already_visited</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
            <span class="pl-c"># print(aa[i][j])</span>
            <span class="pl-s1">array_</span> <span class="pl-c1">=</span> <span class="pl-s1">np</span>.<span class="pl-c1">zeros</span>((<span class="pl-en">len</span>(<span class="pl-s1">aa</span>), <span class="pl-en">len</span>(<span class="pl-s1">aa</span>[<span class="pl-c1">0</span>])))
            <span class="pl-s1">already_visited</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
            <span class="pl-s1">array_</span>[<span class="pl-s1">i</span>][<span class="pl-s1">j</span>] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
            <span class="pl-k">def</span> <span class="pl-en">dfs</span>(<span class="pl-s1">pos</span>):
                <span class="pl-k">for</span> <span class="pl-s1">next_pos</span> <span class="pl-c1">in</span> <span class="pl-en">get_allow_pos</span>(<span class="pl-s1">pos</span>):
                    <span class="pl-k">if</span> <span class="pl-s1">already_visited</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">==</span> <span class="pl-c1">0</span>:
                        <span class="pl-s1">already_visited</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                        <span class="pl-s1">array_</span>[<span class="pl-s1">next_pos</span>[<span class="pl-c1">0</span>]][<span class="pl-s1">next_pos</span>[<span class="pl-c1">1</span>]] <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                        
                        <span class="pl-en">dfs</span>(<span class="pl-s1">next_pos</span>)
            
            <span class="pl-en">dfs</span>((<span class="pl-s1">i</span>, <span class="pl-s1">j</span>))
            <span class="pl-s1">area</span> <span class="pl-c1">=</span> <span class="pl-en">get_area</span>(<span class="pl-s1">array_</span>)
            <span class="pl-s1">perimeter</span> <span class="pl-c1">=</span> <span class="pl-en">get_perimeter</span>(<span class="pl-s1">array_</span>)
            <span class="pl-c"># print(perimeter)</span>
            <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-s1">area</span> <span class="pl-c1">*</span> <span class="pl-s1">perimeter</span>
        
<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<blockquote>
<p>一条边有两个角, 找到所有角之后整除2即可</p>
</blockquote>
<h2>第十三题</h2>
<p><a href="https://adventofcode.com/2024/day/13" rel="nofollow">https://adventofcode.com/2024/day/13</a></p>
<h3>1题</h3>
<p>按下按钮A或B, 移动老虎爪, 让老虎爪移动到指定的位置, 按下A需要三块钱, B需要一块钱<br>
有可能无解(无法移动到指定位置)</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">split</span>(<span class="pl-s">'<span class="pl-cce">\n</span><span class="pl-cce">\n</span>'</span>)
<span class="pl-k">from</span> <span class="pl-s1">sympy</span> <span class="pl-k">import</span> <span class="pl-c1">*</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">aa</span>:
    <span class="pl-s1">inputs</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>.<span class="pl-c1">split</span>(<span class="pl-s">'<span class="pl-cce">\n</span>'</span>)
    <span class="pl-c"># 提取输入</span>
    <span class="pl-s1">ax</span>, <span class="pl-s1">ay</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">0</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">bx</span>, <span class="pl-s1">by</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">t1</span>, <span class="pl-s1">t2</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">2</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">ax</span>, <span class="pl-s1">ay</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">ax</span>[<span class="pl-c1">2</span>:]), <span class="pl-en">int</span>(<span class="pl-s1">ay</span>[<span class="pl-c1">2</span>:])
    <span class="pl-s1">bx</span>, <span class="pl-s1">by</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">bx</span>[<span class="pl-c1">2</span>:]), <span class="pl-en">int</span>(<span class="pl-s1">by</span>[<span class="pl-c1">2</span>:])
    <span class="pl-s1">t1</span>, <span class="pl-s1">t2</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">t1</span>[<span class="pl-c1">2</span>:]), <span class="pl-en">int</span>(<span class="pl-s1">t2</span>[<span class="pl-c1">2</span>:])
    <span class="pl-s1">m</span> <span class="pl-c1">=</span> <span class="pl-en">Symbol</span>(<span class="pl-s">'m'</span>)
    <span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-en">Symbol</span>(<span class="pl-s">'n'</span>)
    <span class="pl-s1">temp</span> <span class="pl-c1">=</span> <span class="pl-en">solve</span>([<span class="pl-s1">m</span> <span class="pl-c1">*</span> <span class="pl-s1">ax</span> <span class="pl-c1">+</span> <span class="pl-s1">n</span> <span class="pl-c1">*</span> <span class="pl-s1">bx</span> <span class="pl-c1">-</span> <span class="pl-s1">t1</span>, <span class="pl-s1">m</span> <span class="pl-c1">*</span> <span class="pl-s1">ay</span> <span class="pl-c1">+</span> <span class="pl-s1">n</span> <span class="pl-c1">*</span> <span class="pl-s1">by</span> <span class="pl-c1">-</span> <span class="pl-s1">t2</span>], [<span class="pl-s1">m</span>, <span class="pl-s1">n</span>])
    <span class="pl-c"># print(temp)</span>
    <span class="pl-k">if</span> <span class="pl-s1">temp</span>[<span class="pl-s1">m</span>].<span class="pl-c1">is_Integer</span> <span class="pl-c1">and</span> <span class="pl-s1">temp</span>[<span class="pl-s1">n</span>].<span class="pl-c1">is_Integer</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-en">int</span>(<span class="pl-s1">temp</span>[<span class="pl-s1">m</span>]) <span class="pl-c1">*</span> <span class="pl-c1">3</span> <span class="pl-c1">+</span> <span class="pl-en">int</span>(<span class="pl-s1">temp</span>[<span class="pl-s1">n</span>])

<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
&gt; 二元一次方程组的整数解
<h3>2题</h3>
<p>在一题的基础上, X轴和Y轴上都高出10000000000000(大数)</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-s1">aa</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">split</span>(<span class="pl-s">'<span class="pl-cce">\n</span><span class="pl-cce">\n</span>'</span>)
<span class="pl-k">from</span> <span class="pl-s1">sympy</span> <span class="pl-k">import</span> <span class="pl-c1">*</span>

<span class="pl-s1">ans</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-s1">aa</span>:
    <span class="pl-s1">inputs</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>.<span class="pl-c1">split</span>(<span class="pl-s">'<span class="pl-cce">\n</span>'</span>)
    <span class="pl-c"># 提取输入</span>
    <span class="pl-s1">ax</span>, <span class="pl-s1">ay</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">0</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">bx</span>, <span class="pl-s1">by</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">t1</span>, <span class="pl-s1">t2</span> <span class="pl-c1">=</span> <span class="pl-s1">inputs</span>[<span class="pl-c1">2</span>].<span class="pl-c1">split</span>(<span class="pl-s">': '</span>)[<span class="pl-c1">1</span>].<span class="pl-c1">split</span>(<span class="pl-s">', '</span>)
    <span class="pl-s1">ax</span>, <span class="pl-s1">ay</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">ax</span>[<span class="pl-c1">2</span>:]), <span class="pl-en">int</span>(<span class="pl-s1">ay</span>[<span class="pl-c1">2</span>:])
    <span class="pl-s1">bx</span>, <span class="pl-s1">by</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">bx</span>[<span class="pl-c1">2</span>:]), <span class="pl-en">int</span>(<span class="pl-s1">by</span>[<span class="pl-c1">2</span>:])
    <span class="pl-s1">t1</span>, <span class="pl-s1">t2</span> <span class="pl-c1">=</span> <span class="pl-en">int</span>(<span class="pl-s1">t1</span>[<span class="pl-c1">2</span>:]) <span class="pl-c1">+</span> <span class="pl-c1">10000000000000</span>, <span class="pl-en">int</span>(<span class="pl-s1">t2</span>[<span class="pl-c1">2</span>:]) <span class="pl-c1">+</span> <span class="pl-c1">10000000000000</span>
    <span class="pl-s1">m</span> <span class="pl-c1">=</span> <span class="pl-en">Symbol</span>(<span class="pl-s">'m'</span>)
    <span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-en">Symbol</span>(<span class="pl-s">'n'</span>)
    <span class="pl-s1">temp</span> <span class="pl-c1">=</span> <span class="pl-en">solve</span>([<span class="pl-s1">m</span> <span class="pl-c1">*</span> <span class="pl-s1">ax</span> <span class="pl-c1">+</span> <span class="pl-s1">n</span> <span class="pl-c1">*</span> <span class="pl-s1">bx</span> <span class="pl-c1">-</span> <span class="pl-s1">t1</span>, <span class="pl-s1">m</span> <span class="pl-c1">*</span> <span class="pl-s1">ay</span> <span class="pl-c1">+</span> <span class="pl-s1">n</span> <span class="pl-c1">*</span> <span class="pl-s1">by</span> <span class="pl-c1">-</span> <span class="pl-s1">t2</span>], [<span class="pl-s1">m</span>, <span class="pl-s1">n</span>])
    <span class="pl-c"># print(temp)</span>
    <span class="pl-k">if</span> <span class="pl-s1">temp</span>[<span class="pl-s1">m</span>].<span class="pl-c1">is_Integer</span> <span class="pl-c1">and</span> <span class="pl-s1">temp</span>[<span class="pl-s1">n</span>].<span class="pl-c1">is_Integer</span>:
        <span class="pl-s1">ans</span> <span class="pl-c1">+=</span> <span class="pl-en">int</span>(<span class="pl-s1">temp</span>[<span class="pl-s1">m</span>]) <span class="pl-c1">*</span> <span class="pl-c1">3</span> <span class="pl-c1">+</span> <span class="pl-en">int</span>(<span class="pl-s1">temp</span>[<span class="pl-s1">n</span>])

<span class="pl-en">print</span>(<span class="pl-s1">ans</span>)</pre></div>
<p></p>
</details> 
<blockquote>
<p>python无限精度整数, 不需要额外处理</p>
</blockquote>
<h2>第十四题</h2>
<p><a href="https://adventofcode.com/2024/day/14" rel="nofollow">https://adventofcode.com/2024/day/14</a></p>
<h3>1题</h3>
<p>给定点坐标, 点的移动速度, 大小固定的图</p>
<p>求 四个象限内点的数量 之积<br>
象限是去掉最中间一列与一行使得图分成四个区域<br>
点到边界会传送到另一侧 (mod)</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">main</span>():
    <span class="pl-s1">lines</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>()

    <span class="pl-s1">robots</span> <span class="pl-c1">=</span> []
    <span class="pl-k">for</span> <span class="pl-s1">line</span> <span class="pl-c1">in</span> <span class="pl-s1">lines</span>:
        <span class="pl-s1">p_part</span>, <span class="pl-s1">v_part</span> <span class="pl-c1">=</span> <span class="pl-s1">line</span>.<span class="pl-c1">strip</span>().<span class="pl-c1">split</span>()
        <span class="pl-s1">p_x</span>, <span class="pl-s1">p_y</span> <span class="pl-c1">=</span> <span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-s1">p_part</span>[<span class="pl-c1">2</span>:].<span class="pl-c1">split</span>(<span class="pl-s">','</span>))
        <span class="pl-s1">v_x</span>, <span class="pl-s1">v_y</span> <span class="pl-c1">=</span> <span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-s1">v_part</span>[<span class="pl-c1">2</span>:].<span class="pl-c1">split</span>(<span class="pl-s">','</span>))
        <span class="pl-s1">robots</span>.<span class="pl-c1">append</span>({<span class="pl-s">'p'</span>: (<span class="pl-s1">p_x</span>, <span class="pl-s1">p_y</span>), <span class="pl-s">'v'</span>: (<span class="pl-s1">v_x</span>, <span class="pl-s1">v_y</span>)})

    <span class="pl-s1">positions</span> <span class="pl-c1">=</span> {}
    <span class="pl-k">for</span> <span class="pl-s1">robot</span> <span class="pl-c1">in</span> <span class="pl-s1">robots</span>:
        <span class="pl-s1">x</span> <span class="pl-c1">=</span> (<span class="pl-s1">robot</span>[<span class="pl-s">'p'</span>][<span class="pl-c1">0</span>] <span class="pl-c1">+</span> <span class="pl-s1">robot</span>[<span class="pl-s">'v'</span>][<span class="pl-c1">0</span>] <span class="pl-c1">*</span> <span class="pl-c1">100</span>) <span class="pl-c1">%</span> <span class="pl-c1">101</span>
        <span class="pl-s1">y</span> <span class="pl-c1">=</span> (<span class="pl-s1">robot</span>[<span class="pl-s">'p'</span>][<span class="pl-c1">1</span>] <span class="pl-c1">+</span> <span class="pl-s1">robot</span>[<span class="pl-s">'v'</span>][<span class="pl-c1">1</span>] <span class="pl-c1">*</span> <span class="pl-c1">100</span>) <span class="pl-c1">%</span> <span class="pl-c1">103</span>
        <span class="pl-s1">positions</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>)] <span class="pl-c1">=</span> <span class="pl-s1">positions</span>.<span class="pl-c1">get</span>((<span class="pl-s1">x</span>, <span class="pl-s1">y</span>), <span class="pl-c1">0</span>) <span class="pl-c1">+</span> <span class="pl-c1">1</span>

    <span class="pl-s1">q1</span> <span class="pl-c1">=</span> <span class="pl-s1">q2</span> <span class="pl-c1">=</span> <span class="pl-s1">q3</span> <span class="pl-c1">=</span> <span class="pl-s1">q4</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">for</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>), <span class="pl-s1">count</span> <span class="pl-c1">in</span> <span class="pl-s1">positions</span>.<span class="pl-c1">items</span>():
        <span class="pl-k">if</span> <span class="pl-s1">x</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">50</span> <span class="pl-c1">and</span> <span class="pl-s1">y</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">51</span>:
            <span class="pl-s1">q1</span> <span class="pl-c1">+=</span> <span class="pl-s1">count</span>
        <span class="pl-k">elif</span> <span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">50</span> <span class="pl-c1">and</span> <span class="pl-s1">y</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">51</span>:
            <span class="pl-s1">q2</span> <span class="pl-c1">+=</span> <span class="pl-s1">count</span>
        <span class="pl-k">elif</span> <span class="pl-s1">x</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">50</span> <span class="pl-c1">and</span> <span class="pl-s1">y</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">51</span>:
            <span class="pl-s1">q3</span> <span class="pl-c1">+=</span> <span class="pl-s1">count</span>
        <span class="pl-k">elif</span> <span class="pl-s1">x</span> <span class="pl-c1">&lt;</span> <span class="pl-c1">50</span> <span class="pl-c1">and</span> <span class="pl-s1">y</span> <span class="pl-c1">&gt;</span> <span class="pl-c1">51</span>:
            <span class="pl-s1">q4</span> <span class="pl-c1">+=</span> <span class="pl-s1">count</span>

    <span class="pl-s1">safety_factor</span> <span class="pl-c1">=</span> <span class="pl-s1">q1</span> <span class="pl-c1">*</span> <span class="pl-s1">q2</span> <span class="pl-c1">*</span> <span class="pl-s1">q3</span> <span class="pl-c1">*</span> <span class="pl-s1">q4</span>
    <span class="pl-en">print</span>(<span class="pl-s1">safety_factor</span>)

<span class="pl-k">if</span> <span class="pl-s1">__name__</span> <span class="pl-c1">==</span> <span class="pl-s">"__main__"</span>:
    <span class="pl-en">main</span>()</pre></div>
<p></p>
</details> 
<h3>2题</h3>
<p>直接贴原题, 因为原题是阅读理解</p>
<p>During the bathroom break, someone notices that these robots seem awfully similar to ones built and used at the North Pole. If they're the same type of robots, they should have a hard-coded Easter egg: very rarely, most of the robots should arrange themselves into a picture of a Christmas tree.</p>
<blockquote>
<p>在上厕所的时候，有人注意到这些机器人看起来与在北极建造和使用的机器人非常相似。如果它们是同一类型的机器人，它们应该有一个硬编码的复活节彩蛋：极少数情况下，大多数机器人应该将自己排列成圣诞树的图片。</p>
</blockquote>
<p>What is the fewest number of seconds that must elapse for the robots to display the Easter egg?</p>
<blockquote>
<p>机器人展示复活节彩蛋所需的最少秒数是多少？</p>
</blockquote>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">def</span> <span class="pl-en">find_min_unique_t</span>(<span class="pl-s1">input_lines</span>):
    <span class="pl-s1">robots</span> <span class="pl-c1">=</span> []
    <span class="pl-k">for</span> <span class="pl-s1">line</span> <span class="pl-c1">in</span> <span class="pl-s1">input_lines</span>:
        <span class="pl-s1">p_part</span>, <span class="pl-s1">v_part</span> <span class="pl-c1">=</span> <span class="pl-s1">line</span>.<span class="pl-c1">split</span>(<span class="pl-s">' v='</span>)
        <span class="pl-s1">x</span>, <span class="pl-s1">y</span> <span class="pl-c1">=</span> <span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-s1">p_part</span>[<span class="pl-c1">2</span>:].<span class="pl-c1">split</span>(<span class="pl-s">','</span>))
        <span class="pl-s1">dx</span>, <span class="pl-s1">dy</span> <span class="pl-c1">=</span> <span class="pl-en">map</span>(<span class="pl-s1">int</span>, <span class="pl-s1">v_part</span>.<span class="pl-c1">split</span>(<span class="pl-s">','</span>))
        <span class="pl-s1">robots</span>.<span class="pl-c1">append</span>({<span class="pl-s">'x'</span>: <span class="pl-s1">x</span>, <span class="pl-s">'y'</span>: <span class="pl-s1">y</span>, <span class="pl-s">'dx'</span>: <span class="pl-s1">dx</span>, <span class="pl-s">'dy'</span>: <span class="pl-s1">dy</span>})
    
    <span class="pl-k">for</span> <span class="pl-s1">t</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-c1">10403</span>):
        <span class="pl-s1">position_map</span> <span class="pl-c1">=</span> {}
        <span class="pl-k">for</span> <span class="pl-s1">robot</span> <span class="pl-c1">in</span> <span class="pl-s1">robots</span>:
            <span class="pl-s1">x</span> <span class="pl-c1">=</span> (<span class="pl-s1">robot</span>[<span class="pl-s">'x'</span>] <span class="pl-c1">+</span> <span class="pl-s1">robot</span>[<span class="pl-s">'dx'</span>] <span class="pl-c1">*</span> <span class="pl-s1">t</span>) <span class="pl-c1">%</span> <span class="pl-c1">101</span>
            <span class="pl-s1">y</span> <span class="pl-c1">=</span> (<span class="pl-s1">robot</span>[<span class="pl-s">'y'</span>] <span class="pl-c1">+</span> <span class="pl-s1">robot</span>[<span class="pl-s">'dy'</span>] <span class="pl-c1">*</span> <span class="pl-s1">t</span>) <span class="pl-c1">%</span> <span class="pl-c1">103</span>
            <span class="pl-s1">position</span> <span class="pl-c1">=</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>)
            <span class="pl-k">if</span> <span class="pl-s1">position</span> <span class="pl-c1">in</span> <span class="pl-s1">position_map</span>:
                <span class="pl-k">break</span>
            <span class="pl-k">else</span>:
                <span class="pl-s1">position_map</span>[<span class="pl-s1">position</span>] <span class="pl-c1">=</span> <span class="pl-c1">True</span>
        <span class="pl-k">else</span>:
            <span class="pl-k">return</span> <span class="pl-s1">t</span>
    <span class="pl-k">return</span> <span class="pl-c1">-</span><span class="pl-c1">1</span>

<span class="pl-s1">input_lines</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>()

<span class="pl-s1">min_t</span> <span class="pl-c1">=</span> <span class="pl-en">find_min_unique_t</span>(<span class="pl-s1">input_lines</span>)
<span class="pl-en">print</span>(<span class="pl-s">"最小的秒数是:"</span>, <span class="pl-s1">min_t</span>)</pre></div>
<p></p>
</details> 
<blockquote>
<p>这题等价于, 每个机器人不互相重合的时间(题目特意设计过)<br>
如果有其他解法(理解)可以在评论区交流</p>
</blockquote>
<h2>第十五题</h2>
<p><a href="https://adventofcode.com/2024/day/15" rel="nofollow">https://adventofcode.com/2024/day/15</a></p>
<h3>1题</h3>
<p>推箱子</p>
<details><summary>Details</summary>
<p>
</p><p>aa, bb = a.split('\n\n')</p>
<p>all_map = [list(i) for i in aa.splitlines()]</p>
<p>step = ''.join(bb.splitlines())</p>
<p>def is_edge(x, y):<br>
return x &lt; 0 or y &lt; 0 or x &gt;= len(all_map) or y &gt;= len(all_map[0]) or all_map[x][y] == '#'</p>
<p>def get_robot_pos():<br>
for i in range(len(all_map)):<br>
for j in range(len(all_map[0])):<br>
if all_map[i][j] == '@':<br>
return i, j</p>
<p>directions = {'&gt;': (0,1), 'v': (1,0), '&lt;': (0,-1), '^': (-1,0)}</p>
<p>def move(pos, move_to):<br>
temp = []<br>
x, y = pos<br>
dx, dy = move_to<br>
for i in range(1, max(len(all_map), len(all_map[0]))):</p>
<pre class="notranslate"><code class="notranslate">    temp.append(all_map[x][y])

    x += dx
    y += dy
    if not is_edge(x, y):
        if all_map[x][y] == '.':
            # 当前位置开始向前一步
            for _ in range(i):
                all_map[x][y] = temp.pop()
                x -= dx
                y -= dy
            all_map[pos[0]][pos[1]] = '.'
            return (pos[0] + dx, pos[1] + dy)
    else:
        return pos
return pos
</code></pre>
<p>def putty_print(all_map):<br>
for i in all_map:<br>
for j in i:<br>
print(j, end='')<br>
print()</p>
<p>now_pos = get_robot_pos()<br>
for i in step:<br>
now_pos = move(now_pos, directions[i])<br>
putty_print(all_map)</p>
<p>ans = 0<br>
for i in range(len(all_map)):<br>
for j in range(len(all_map[i])):<br>
if all_map[i][j] == 'O':<br>
ans += i * 100 + j</p>
<p>print(ans)</p>
<p></p>
</details> 
<h3>2题</h3>
<p>推更宽(宽一倍), 但是高度不变的箱子</p>
<details><summary>Details</summary>
<p>
</p><p>aa, bb = a.split('\n\n')</p>
<p>all_map = [list(i) for i in aa.splitlines()]</p>
<p>new_map = []<br>
for i in all_map:<br>
temp_map = []<br>
for j in i:<br>
if j == '#':<br>
temp_map.append('#')<br>
temp_map.append('#')<br>
if j == 'O':<br>
temp_map.append('[')<br>
temp_map.append(']')<br>
if j == '.':<br>
temp_map.append('.')<br>
temp_map.append('.')<br>
if j == '@':<br>
temp_map.append('@')<br>
temp_map.append('.')<br>
new_map.append(temp_map)</p>
<p>all_map = new_map<br>
moves = ''.join(bb.splitlines())<br>
def is_edge(x, y):<br>
return x &lt; 0 or y &lt; 0 or x &gt;= len(all_map) or y &gt;= len(all_map[0]) or all_map[x][y] == '#'</p>
<p>def get_robot_pos():<br>
for i in range(len(all_map)):<br>
for j in range(len(all_map[0])):<br>
if all_map[i][j] == '@':<br>
return i, j</p>
<p>directions = {'&gt;': (0,1), 'v': (1,0), '&lt;': (0,-1), '^': (-1,0)}</p>
<p>all_boxes = []</p>
<p>def move(pos, move_to):<br>
temp = []<br>
x, y = pos<br>
dx, dy = move_to<br>
if dx == 0:<br>
for i in range(1, max(len(all_map), len(all_map[0]))):</p>
<pre class="notranslate"><code class="notranslate">        temp.append(all_map[x][y])

        x += dx
        y += dy
        if not is_edge(x, y):
            if all_map[x][y] == '.':
                # 当前位置开始向前一步
                for _ in range(i):
                    all_map[x][y] = temp.pop()
                    x -= dx
                    y -= dy
                all_map[pos[0]][pos[1]] = '.'
                return (pos[0] + dx, pos[1] + dy)
        else:
            return pos
    return pos
else:
    box_pos = []
    next_pos = [(x, y)]
    can_move = True

    while next_pos:
        x, y = next_pos.pop(0)
        x, y = x + dx, y + dy
        if all_map[x][y] == '[':
            box_pos.append(((x, y), (x, y+1)))
            next_pos.append((x, y+1))
            next_pos.append((x, y))
        elif all_map[x][y] == ']':
            box_pos.append(((x, y), (x, y-1)))
            next_pos.append((x, y-1))
            next_pos.append((x, y))
        elif all_map[x][y] == '#':
            can_move = False
            break
        # 去重
        tt = []
        [tt.append(i) for i in next_pos if i not in tt]
        next_pos = tt
    tt = []
    [tt.append(i) for i in box_pos if (i not in tt) and ((i[1], i[0]) not in tt)]
    box_pos = tt
    if not can_move:
        return pos
    else:
        for box in box_pos[::-1]:
            for box_pos in box:
                all_map[box_pos[0] + dx][box_pos[1] + dy] = all_map[box_pos[0]][box_pos[1]]
                all_map[box_pos[0]][box_pos[1]] = '.'

        # 更改@的位置
        all_map[pos[0] + dx][pos[1] + dy] = '@'
        all_map[pos[0]][pos[1]] = '.'
        return (pos[0] + dx, pos[1] + dy)
</code></pre>
<p>def putty_print(all_map):<br>
for i in all_map:<br>
for j in i:<br>
print(j, end='')<br>
print()</p>
<p>now_pos = get_robot_pos()<br>
for i in moves:<br>
now_pos = move(now_pos, directions[i])<br>
putty_print(all_map)</p>
<p>ans = 0<br>
for i in range(len(all_map)):<br>
for j in range(len(all_map[i])):<br>
if all_map[i][j] == '[':<br>
ans += i * 100 + j</p>
<p>print(ans)</p>
<p></p>
</details> 
<blockquote>
<p>横着推可以复用一题代码, 竖着推需要检测所有能推的箱子(bfs)</p>
</blockquote>
<h2>第十六题</h2>
<p><a href="https://adventofcode.com/2024/day/16" rel="nofollow">https://adventofcode.com/2024/day/16</a></p>
<h3>1题</h3>
<p>迷宫 直行+1分 转弯+1000分, 找到最低分数路线</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">heapq</span>

<span class="pl-s1">map</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>()

<span class="pl-k">for</span> <span class="pl-s1">i</span>, <span class="pl-s1">row</span> <span class="pl-c1">in</span> <span class="pl-en">enumerate</span>(<span class="pl-s1">map</span>):
    <span class="pl-k">if</span> <span class="pl-s">'S'</span> <span class="pl-c1">in</span> <span class="pl-s1">row</span>:
        <span class="pl-s1">sx</span>, <span class="pl-s1">sy</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>, <span class="pl-s1">row</span>.<span class="pl-c1">index</span>(<span class="pl-s">'S'</span>)
    <span class="pl-k">if</span> <span class="pl-s">'E'</span> <span class="pl-c1">in</span> <span class="pl-s1">row</span>:
        <span class="pl-s1">ex</span>, <span class="pl-s1">ey</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>, <span class="pl-s1">row</span>.<span class="pl-c1">index</span>(<span class="pl-s">'E'</span>)

<span class="pl-c"># 0东，1南，2西，3北</span>
<span class="pl-s1">directions</span> <span class="pl-c1">=</span> [(<span class="pl-c1">0</span>,<span class="pl-c1">1</span>), (<span class="pl-c1">1</span>,<span class="pl-c1">0</span>), (<span class="pl-c1">0</span>,<span class="pl-c1">-</span><span class="pl-c1">1</span>), (<span class="pl-c1">-</span><span class="pl-c1">1</span>,<span class="pl-c1">0</span>)]

<span class="pl-k">def</span> <span class="pl-en">turn_left</span>(<span class="pl-s1">d</span>):
    <span class="pl-k">return</span> (<span class="pl-s1">d</span> <span class="pl-c1">-</span> <span class="pl-c1">1</span>) <span class="pl-c1">%</span> <span class="pl-c1">4</span>

<span class="pl-k">def</span> <span class="pl-en">turn_right</span>(<span class="pl-s1">d</span>):
    <span class="pl-k">return</span> (<span class="pl-s1">d</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>) <span class="pl-c1">%</span> <span class="pl-c1">4</span>

<span class="pl-c"># 检查位置是否有效（不是墙且在地图内）</span>
<span class="pl-k">def</span> <span class="pl-en">is_valid</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>):
    <span class="pl-k">if</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">x</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">map</span>) <span class="pl-c1">and</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">y</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">map</span>[<span class="pl-c1">0</span>]):
        <span class="pl-k">return</span> <span class="pl-s1">map</span>[<span class="pl-s1">x</span>][<span class="pl-s1">y</span>] <span class="pl-c1">!=</span> <span class="pl-s">'#'</span>
    <span class="pl-k">return</span> <span class="pl-c1">False</span>

<span class="pl-s1">heap</span> <span class="pl-c1">=</span> []
<span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-c1">0</span>, <span class="pl-s1">sx</span>, <span class="pl-s1">sy</span>, <span class="pl-c1">0</span>))

<span class="pl-s1">visited</span> <span class="pl-c1">=</span> {}
<span class="pl-s1">visited</span>[(<span class="pl-s1">sx</span>, <span class="pl-s1">sy</span>, <span class="pl-c1">0</span>)] <span class="pl-c1">=</span> <span class="pl-c1">0</span>

<span class="pl-k">while</span> <span class="pl-s1">heap</span>:
    <span class="pl-s1">current_score</span>, <span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">d</span> <span class="pl-c1">=</span> <span class="pl-s1">heapq</span>.<span class="pl-c1">heappop</span>(<span class="pl-s1">heap</span>)
    <span class="pl-k">if</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>) <span class="pl-c1">==</span> (<span class="pl-s1">ex</span>, <span class="pl-s1">ey</span>):
        <span class="pl-en">print</span>(<span class="pl-s">"最低得分为:"</span>, <span class="pl-s1">current_score</span>)
        <span class="pl-k">break</span>
    <span class="pl-k">if</span> <span class="pl-s1">visited</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">d</span>)] <span class="pl-c1">&lt;</span> <span class="pl-s1">current_score</span>:
        <span class="pl-k">continue</span>  <span class="pl-c"># 已经有更小的得分到达这个状态</span>
    <span class="pl-c"># 尝试前进</span>
    <span class="pl-s1">dx</span>, <span class="pl-s1">dy</span> <span class="pl-c1">=</span> <span class="pl-s1">directions</span>[<span class="pl-s1">d</span>]
    <span class="pl-s1">nx</span>, <span class="pl-s1">ny</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">dx</span>, <span class="pl-s1">y</span> <span class="pl-c1">+</span> <span class="pl-s1">dy</span>
    <span class="pl-k">if</span> <span class="pl-en">is_valid</span>(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>):
        <span class="pl-s1">new_score</span> <span class="pl-c1">=</span> <span class="pl-s1">current_score</span> <span class="pl-c1">+</span> <span class="pl-c1">1</span>
        <span class="pl-k">if</span> (<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">d</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">visited</span> <span class="pl-c1">or</span> <span class="pl-s1">new_score</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">visited</span>[(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">d</span>)]:
            <span class="pl-s1">visited</span>[(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">d</span>)] <span class="pl-c1">=</span> <span class="pl-s1">new_score</span>
            <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-s1">new_score</span>, <span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">d</span>))
    <span class="pl-c"># 尝试左转</span>
    <span class="pl-s1">new_d</span> <span class="pl-c1">=</span> <span class="pl-en">turn_left</span>(<span class="pl-s1">d</span>)
    <span class="pl-s1">new_score</span> <span class="pl-c1">=</span> <span class="pl-s1">current_score</span> <span class="pl-c1">+</span> <span class="pl-c1">1000</span>
    <span class="pl-k">if</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">visited</span> <span class="pl-c1">or</span> <span class="pl-s1">new_score</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">visited</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>)]:
        <span class="pl-s1">visited</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>)] <span class="pl-c1">=</span> <span class="pl-s1">new_score</span>
        <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-s1">new_score</span>, <span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>))
    <span class="pl-c"># 尝试右转</span>
    <span class="pl-s1">new_d</span> <span class="pl-c1">=</span> <span class="pl-en">turn_right</span>(<span class="pl-s1">d</span>)
    <span class="pl-s1">new_score</span> <span class="pl-c1">=</span> <span class="pl-s1">current_score</span> <span class="pl-c1">+</span> <span class="pl-c1">1000</span>
    <span class="pl-k">if</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">visited</span> <span class="pl-c1">or</span> <span class="pl-s1">new_score</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">visited</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>)]:
        <span class="pl-s1">visited</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>)] <span class="pl-c1">=</span> <span class="pl-s1">new_score</span>
        <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-s1">new_score</span>, <span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">new_d</span>))</pre></div>
<p></p>
</details> 
<h3>2题</h3>
<p>遍历所有最优路径, 问走过所有的路有多少格 (这一格至少属于一条最优路径)</p>
<details><summary>Details</summary>
<p>
</p><div class="highlight highlight-source-python"><pre class="notranslate"><span class="pl-k">import</span> <span class="pl-s1">heapq</span>

<span class="pl-c"># 定义图</span>
<span class="pl-s1">grid</span> <span class="pl-c1">=</span> <span class="pl-s1">a</span>.<span class="pl-c1">splitlines</span>()

<span class="pl-c"># 找到起点S和终点E的位置</span>
<span class="pl-k">for</span> <span class="pl-s1">i</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-en">len</span>(<span class="pl-s1">grid</span>)):
    <span class="pl-k">if</span> <span class="pl-s">'S'</span> <span class="pl-c1">in</span> <span class="pl-s1">grid</span>[<span class="pl-s1">i</span>]:
        <span class="pl-s1">sx</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>
        <span class="pl-s1">sy</span> <span class="pl-c1">=</span> <span class="pl-s1">grid</span>[<span class="pl-s1">i</span>].<span class="pl-c1">index</span>(<span class="pl-s">'S'</span>)
    <span class="pl-k">if</span> <span class="pl-s">'E'</span> <span class="pl-c1">in</span> <span class="pl-s1">grid</span>[<span class="pl-s1">i</span>]:
        <span class="pl-s1">ex</span> <span class="pl-c1">=</span> <span class="pl-s1">i</span>
        <span class="pl-s1">ey</span> <span class="pl-c1">=</span> <span class="pl-s1">grid</span>[<span class="pl-s1">i</span>].<span class="pl-c1">index</span>(<span class="pl-s">'E'</span>)

<span class="pl-c"># 定义方向和移动向量</span>
<span class="pl-s1">directions</span> <span class="pl-c1">=</span> [<span class="pl-s">'up'</span>, <span class="pl-s">'right'</span>, <span class="pl-s">'down'</span>, <span class="pl-s">'left'</span>]
<span class="pl-s1">dx</span> <span class="pl-c1">=</span> [<span class="pl-c1">-</span><span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>]
<span class="pl-s1">dy</span> <span class="pl-c1">=</span> [<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">-</span><span class="pl-c1">1</span>]

<span class="pl-c"># Dijkstra算法找到起点到终点的最短路径权重</span>
<span class="pl-k">def</span> <span class="pl-en">dijkstra</span>(<span class="pl-s1">start_x</span>, <span class="pl-s1">start_y</span>, <span class="pl-s1">end_x</span>, <span class="pl-s1">end_y</span>):
    <span class="pl-s1">heap</span> <span class="pl-c1">=</span> []
    <span class="pl-s1">initial_direction</span> <span class="pl-c1">=</span> <span class="pl-c1">0</span>  <span class="pl-c"># 向上</span>
    <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-c1">0</span>, <span class="pl-s1">start_x</span>, <span class="pl-s1">start_y</span>, <span class="pl-s1">initial_direction</span>))
    <span class="pl-s1">visited</span> <span class="pl-c1">=</span> {}
    <span class="pl-s1">visited</span>[(<span class="pl-s1">start_x</span>, <span class="pl-s1">start_y</span>, <span class="pl-s1">initial_direction</span>)] <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> <span class="pl-s1">heap</span>:
        <span class="pl-s1">current_weight</span>, <span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">direction</span> <span class="pl-c1">=</span> <span class="pl-s1">heapq</span>.<span class="pl-c1">heappop</span>(<span class="pl-s1">heap</span>)
        <span class="pl-k">if</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>) <span class="pl-c1">==</span> (<span class="pl-s1">end_x</span>, <span class="pl-s1">end_y</span>):
            <span class="pl-k">return</span> <span class="pl-s1">current_weight</span>
        <span class="pl-k">for</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-c1">4</span>):
            <span class="pl-s1">nx</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">dx</span>[<span class="pl-s1">new_direction</span>]
            <span class="pl-s1">ny</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span> <span class="pl-c1">+</span> <span class="pl-s1">dy</span>[<span class="pl-s1">new_direction</span>]
            <span class="pl-k">if</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">nx</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>) <span class="pl-c1">and</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">ny</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">and</span> <span class="pl-s1">grid</span>[<span class="pl-s1">nx</span>][<span class="pl-s1">ny</span>] <span class="pl-c1">!=</span> <span class="pl-s">'#'</span>:
                <span class="pl-k">if</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">==</span> <span class="pl-s1">direction</span>:
                    <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                <span class="pl-k">else</span>:
                    <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1000</span>
                <span class="pl-s1">total_weight</span> <span class="pl-c1">=</span> <span class="pl-s1">current_weight</span> <span class="pl-c1">+</span> <span class="pl-s1">cost</span>
                <span class="pl-k">if</span> (<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">visited</span> <span class="pl-c1">or</span> <span class="pl-s1">total_weight</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">visited</span>.<span class="pl-c1">get</span>((<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>), <span class="pl-en">float</span>(<span class="pl-s">'inf'</span>)):
                    <span class="pl-s1">visited</span>[(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>)] <span class="pl-c1">=</span> <span class="pl-s1">total_weight</span>
                    <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-s1">total_weight</span>, <span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>))
    <span class="pl-k">return</span> <span class="pl-en">float</span>(<span class="pl-s">'inf'</span>)

<span class="pl-c"># 正向Dijkstra</span>
<span class="pl-s1">shortest_weight</span> <span class="pl-c1">=</span> <span class="pl-en">dijkstra</span>(<span class="pl-s1">sx</span>, <span class="pl-s1">sy</span>, <span class="pl-s1">ex</span>, <span class="pl-s1">ey</span>)

<span class="pl-c"># 反向Dijkstra，从终点到每个位置的最小累计权重</span>
<span class="pl-k">def</span> <span class="pl-en">reverse_dijkstra</span>(<span class="pl-s1">end_x</span>, <span class="pl-s1">end_y</span>, <span class="pl-s1">start_x</span>, <span class="pl-s1">start_y</span>):
    <span class="pl-s1">heap</span> <span class="pl-c1">=</span> []
    <span class="pl-s1">initial_direction</span> <span class="pl-c1">=</span> <span class="pl-c1">2</span>  <span class="pl-c"># 向下，因为反向</span>
    <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-c1">0</span>, <span class="pl-s1">end_x</span>, <span class="pl-s1">end_y</span>, <span class="pl-s1">initial_direction</span>))
    <span class="pl-s1">visited</span> <span class="pl-c1">=</span> {}
    <span class="pl-s1">visited</span>[(<span class="pl-s1">end_x</span>, <span class="pl-s1">end_y</span>, <span class="pl-s1">initial_direction</span>)] <span class="pl-c1">=</span> <span class="pl-c1">0</span>
    <span class="pl-s1">to_end_min</span> <span class="pl-c1">=</span> {}
    <span class="pl-k">while</span> <span class="pl-s1">heap</span>:
        <span class="pl-s1">current_weight</span>, <span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">direction</span> <span class="pl-c1">=</span> <span class="pl-s1">heapq</span>.<span class="pl-c1">heappop</span>(<span class="pl-s1">heap</span>)
        <span class="pl-s1">to_end_min</span>[(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>)] <span class="pl-c1">=</span> <span class="pl-en">min</span>(<span class="pl-s1">to_end_min</span>.<span class="pl-c1">get</span>((<span class="pl-s1">x</span>, <span class="pl-s1">y</span>), <span class="pl-en">float</span>(<span class="pl-s">'inf'</span>)), <span class="pl-s1">current_weight</span>)
        <span class="pl-k">for</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-c1">4</span>):
            <span class="pl-s1">nx</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">dx</span>[<span class="pl-s1">new_direction</span>]
            <span class="pl-s1">ny</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span> <span class="pl-c1">+</span> <span class="pl-s1">dy</span>[<span class="pl-s1">new_direction</span>]
            <span class="pl-k">if</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">nx</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>) <span class="pl-c1">and</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">ny</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">and</span> <span class="pl-s1">grid</span>[<span class="pl-s1">nx</span>][<span class="pl-s1">ny</span>] <span class="pl-c1">!=</span> <span class="pl-s">'#'</span>:
                <span class="pl-k">if</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">==</span> <span class="pl-s1">direction</span>:
                    <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>
                <span class="pl-k">else</span>:
                    <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1000</span>
                <span class="pl-s1">total_weight</span> <span class="pl-c1">=</span> <span class="pl-s1">current_weight</span> <span class="pl-c1">+</span> <span class="pl-s1">cost</span>
                <span class="pl-k">if</span> (<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">visited</span> <span class="pl-c1">or</span> <span class="pl-s1">total_weight</span> <span class="pl-c1">&lt;</span> <span class="pl-s1">visited</span>.<span class="pl-c1">get</span>((<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>), <span class="pl-en">float</span>(<span class="pl-s">'inf'</span>)):
                    <span class="pl-s1">visited</span>[(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>)] <span class="pl-c1">=</span> <span class="pl-s1">total_weight</span>
                    <span class="pl-s1">heapq</span>.<span class="pl-c1">heappush</span>(<span class="pl-s1">heap</span>, (<span class="pl-s1">total_weight</span>, <span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>))
    <span class="pl-k">return</span> <span class="pl-s1">to_end_min</span>

<span class="pl-s1">to_end_min</span> <span class="pl-c1">=</span> <span class="pl-en">reverse_dijkstra</span>(<span class="pl-s1">ex</span>, <span class="pl-s1">ey</span>, <span class="pl-s1">sx</span>, <span class="pl-s1">sy</span>)

<span class="pl-c"># DFS找出所有最短路径</span>
<span class="pl-s1">paths</span> <span class="pl-c1">=</span> []
<span class="pl-k">def</span> <span class="pl-en">dfs</span>(<span class="pl-s1">x</span>, <span class="pl-s1">y</span>, <span class="pl-s1">direction</span>, <span class="pl-s1">path</span>, <span class="pl-s1">current_weight</span>):
    <span class="pl-s1">path</span>.<span class="pl-c1">append</span>((<span class="pl-s1">x</span>, <span class="pl-s1">y</span>))
    <span class="pl-k">if</span> (<span class="pl-s1">x</span>, <span class="pl-s1">y</span>) <span class="pl-c1">==</span> (<span class="pl-s1">ex</span>, <span class="pl-s1">ey</span>):
        <span class="pl-k">if</span> <span class="pl-s1">current_weight</span> <span class="pl-c1">==</span> <span class="pl-s1">shortest_weight</span>:
            <span class="pl-s1">paths</span>.<span class="pl-c1">append</span>(<span class="pl-s1">path</span>.<span class="pl-c1">copy</span>())
        <span class="pl-s1">path</span>.<span class="pl-c1">pop</span>()
        <span class="pl-k">return</span>
    <span class="pl-k">for</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">in</span> <span class="pl-en">range</span>(<span class="pl-c1">4</span>):
        <span class="pl-s1">nx</span> <span class="pl-c1">=</span> <span class="pl-s1">x</span> <span class="pl-c1">+</span> <span class="pl-s1">dx</span>[<span class="pl-s1">new_direction</span>]
        <span class="pl-s1">ny</span> <span class="pl-c1">=</span> <span class="pl-s1">y</span> <span class="pl-c1">+</span> <span class="pl-s1">dy</span>[<span class="pl-s1">new_direction</span>]
        <span class="pl-k">if</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">nx</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>) <span class="pl-c1">and</span> <span class="pl-c1">0</span> <span class="pl-c1">&lt;=</span> <span class="pl-s1">ny</span> <span class="pl-c1">&lt;</span> <span class="pl-en">len</span>(<span class="pl-s1">grid</span>[<span class="pl-c1">0</span>]) <span class="pl-c1">and</span> <span class="pl-s1">grid</span>[<span class="pl-s1">nx</span>][<span class="pl-s1">ny</span>] <span class="pl-c1">!=</span> <span class="pl-s">'#'</span> <span class="pl-c1">and</span> (<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>) <span class="pl-c1"><span class="pl-c1">not</span> <span class="pl-c1">in</span></span> <span class="pl-s1">path</span>:
            <span class="pl-k">if</span> <span class="pl-s1">new_direction</span> <span class="pl-c1">==</span> <span class="pl-s1">direction</span>:
                <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1</span>
            <span class="pl-k">else</span>:
                <span class="pl-s1">cost</span> <span class="pl-c1">=</span> <span class="pl-c1">1000</span>
            <span class="pl-k">if</span> <span class="pl-s1">current_weight</span> <span class="pl-c1">+</span> <span class="pl-s1">cost</span> <span class="pl-c1">+</span> <span class="pl-s1">to_end_min</span>.<span class="pl-c1">get</span>((<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>), <span class="pl-en">float</span>(<span class="pl-s">'inf'</span>)) <span class="pl-c1">&gt;</span> <span class="pl-s1">shortest_weight</span>:
                <span class="pl-k">continue</span>
            <span class="pl-en">dfs</span>(<span class="pl-s1">nx</span>, <span class="pl-s1">ny</span>, <span class="pl-s1">new_direction</span>, <span class="pl-s1">path</span>, <span class="pl-s1">current_weight</span> <span class="pl-c1">+</span> <span class="pl-s1">cost</span>)
    <span class="pl-s1">path</span>.<span class="pl-c1">pop</span>()

<span class="pl-en">dfs</span>(<span class="pl-s1">sx</span>, <span class="pl-s1">sy</span>, <span class="pl-c1">0</span>, [], <span class="pl-c1">0</span>)

<span class="pl-c"># 输出结果</span>
<span class="pl-en">print</span>(<span class="pl-s">"总路径数量:"</span>, <span class="pl-en">len</span>(<span class="pl-s1">paths</span>))
<span class="pl-en">print</span>(<span class="pl-s">"最短路径权重:"</span>, <span class="pl-s1">shortest_weight</span>)
<span class="pl-en">print</span>(<span class="pl-s">"所有最短路径:"</span>)
<span class="pl-s1">ans</span> <span class="pl-c1">=</span> []
<span class="pl-k">for</span> <span class="pl-s1">path</span> <span class="pl-c1">in</span> <span class="pl-s1">paths</span>:
    <span class="pl-s1">ans</span>.<span class="pl-c1">extend</span>(<span class="pl-s1">path</span>)

<span class="pl-en">print</span>(<span class="pl-en">len</span>(<span class="pl-en">list</span>(<span class="pl-en">set</span>(<span class="pl-s1">ans</span>))))</pre></div>
<p></p>
</details> </div>
<div style="font-size:small;margin-top:8px;float:right;">转载无需注明出处</div>

<button class="btn btn-block" type="button" onclick="openComments()" id="cmButton">评论</button>
<div class="comments" id="comments"></div>

</div>
    <div id="footer"><div id="footer1">Copyright © <span id="copyrightYear"></span> <a href="https://FairyOwO.github.io">FairyOwO 的 Blog</a></div>
<div id="footer2">
    <span id="runday"></span><span>Powered by <a href="https://meekdai.com/Gmeek.html" target="_blank">Gmeek</a></span>
</div>

<script>
var now=new Date();
document.getElementById("copyrightYear").innerHTML=now.getFullYear();

if("11/22/2024"!=""){
    var startSite=new Date("11/22/2024");
    var diff=now.getTime()-startSite.getTime();
    var diffDay=Math.floor(diff/(1000*60*60*24));
    document.getElementById("runday").innerHTML="网站运行 "+diffDay+" 天"+" • ";
}
</script></div>
</body>
<script>
var IconList={'sun': 'M8 10.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5zM8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0V.75A.75.75 0 018 0zm0 13a.75.75 0 01.75.75v1.5a.75.75 0 01-1.5 0v-1.5A.75.75 0 018 13zM2.343 2.343a.75.75 0 011.061 0l1.06 1.061a.75.75 0 01-1.06 1.06l-1.06-1.06a.75.75 0 010-1.06zm9.193 9.193a.75.75 0 011.06 0l1.061 1.06a.75.75 0 01-1.06 1.061l-1.061-1.06a.75.75 0 010-1.061zM16 8a.75.75 0 01-.75.75h-1.5a.75.75 0 010-1.5h1.5A.75.75 0 0116 8zM3 8a.75.75 0 01-.75.75H.75a.75.75 0 010-1.5h1.5A.75.75 0 013 8zm10.657-5.657a.75.75 0 010 1.061l-1.061 1.06a.75.75 0 11-1.06-1.06l1.06-1.06a.75.75 0 011.06 0zm-9.193 9.193a.75.75 0 010 1.06l-1.06 1.061a.75.75 0 11-1.061-1.06l1.06-1.061a.75.75 0 011.061 0z', 'moon': 'M9.598 1.591a.75.75 0 01.785-.175 7 7 0 11-8.967 8.967.75.75 0 01.961-.96 5.5 5.5 0 007.046-7.046.75.75 0 01.175-.786zm1.616 1.945a7 7 0 01-7.678 7.678 5.5 5.5 0 107.678-7.678z', 'sync': 'M1.705 8.005a.75.75 0 0 1 .834.656 5.5 5.5 0 0 0 9.592 2.97l-1.204-1.204a.25.25 0 0 1 .177-.427h3.646a.25.25 0 0 1 .25.25v3.646a.25.25 0 0 1-.427.177l-1.38-1.38A7.002 7.002 0 0 1 1.05 8.84a.75.75 0 0 1 .656-.834ZM8 2.5a5.487 5.487 0 0 0-4.131 1.869l1.204 1.204A.25.25 0 0 1 4.896 6H1.25A.25.25 0 0 1 1 5.75V2.104a.25.25 0 0 1 .427-.177l1.38 1.38A7.002 7.002 0 0 1 14.95 7.16a.75.75 0 0 1-1.49.178A5.5 5.5 0 0 0 8 2.5Z', 'home': 'M6.906.664a1.749 1.749 0 0 1 2.187 0l5.25 4.2c.415.332.657.835.657 1.367v7.019A1.75 1.75 0 0 1 13.25 15h-3.5a.75.75 0 0 1-.75-.75V9H7v5.25a.75.75 0 0 1-.75.75h-3.5A1.75 1.75 0 0 1 1 13.25V6.23c0-.531.242-1.034.657-1.366l5.25-4.2Zm1.25 1.171a.25.25 0 0 0-.312 0l-5.25 4.2a.25.25 0 0 0-.094.196v7.019c0 .138.112.25.25.25H5.5V8.25a.75.75 0 0 1 .75-.75h3.5a.75.75 0 0 1 .75.75v5.25h2.75a.25.25 0 0 0 .25-.25V6.23a.25.25 0 0 0-.094-.195Z', 'github': 'M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z', 'copy': 'M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z', 'check': 'M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z'};
var utterancesLoad=0;

let themeSettings={
    "dark": ["dark","moon","#00f0ff","dark-blue"],
    "light": ["light","sun","#ff5000","github-light"],
    "auto": ["auto","sync","","preferred-color-scheme"]
};
function changeTheme(mode, icon, color, utheme){
    document.documentElement.setAttribute("data-color-mode",mode);
    document.getElementById("themeSwitch").setAttribute("d",value=IconList[icon]);
    document.getElementById("themeSwitch").parentNode.style.color=color;
    if(utterancesLoad==1){utterancesTheme(utheme);}
}
function modeSwitch(){
    let currentMode=document.documentElement.getAttribute('data-color-mode');
    let newMode = currentMode === "light" ? "dark" : currentMode === "dark" ? "auto" : "light";
    localStorage.setItem("meek_theme", newMode);
    if(themeSettings[newMode]){
        changeTheme(...themeSettings[newMode]);
    }
}
function utterancesTheme(theme){
    const message={type:'set-theme',theme: theme};
    const iframe=document.getElementsByClassName('utterances-frame')[0];
    iframe.contentWindow.postMessage(message,'https://utteranc.es');
}
if(themeSettings[theme]){changeTheme(...themeSettings[theme]);}
console.log("\n %c Gmeek last https://github.com/Meekdai/Gmeek \n","padding:5px 0;background:#02d81d;color:#fff");
</script>

<script>
document.getElementById("pathHome").setAttribute("d",IconList["home"]);
document.getElementById("pathIssue").setAttribute("d",IconList["github"]);



function openComments(){
    cm=document.getElementById("comments");
    cmButton=document.getElementById("cmButton");
    cmButton.disabled=true;
    cmButton.innerHTML="loading";
    span=document.createElement("span");
    span.setAttribute("class","AnimatedEllipsis");
    cmButton.appendChild(span);

    script=document.createElement("script");
    script.setAttribute("src","https://utteranc.es/client.js");
    script.setAttribute("repo","FairyOwO/FairyOwO.github.io");
    script.setAttribute("issue-term","title");
    
    if(localStorage.getItem("meek_theme")=="dark"){script.setAttribute("theme","dark-blue");}
    else if(localStorage.getItem("meek_theme")=="light") {script.setAttribute("theme","github-light");}
    else{script.setAttribute("theme","preferred-color-scheme");}
    
    script.setAttribute("crossorigin","anonymous");
    script.setAttribute("async","");
    cm.appendChild(script);

    int=self.setInterval("iFrameLoading()",200);
}

function iFrameLoading(){
    var utterances=document.getElementsByClassName('utterances');
    if(utterances.length==1){
        if(utterances[0].style.height!=""){
            utterancesLoad=1;
            int=window.clearInterval(int);
            document.getElementById("cmButton").style.display="none";
            console.log("utterances Load OK");
        }
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const createClipboardHTML = (codeContent, additionalClasses = '') => `
        <pre class="notranslate"><code class="notranslate">${codeContent}</code></pre>
        <div class="clipboard-container position-absolute right-0 top-0 ${additionalClasses}">
            <clipboard-copy class="ClipboardButton btn m-2 p-0" role="button" style="display: inherit;">
                <svg height="16" width="16" class="octicon octicon-copy m-2"><path d="${IconList["copy"]}"></path></svg>
                <svg height="16" width="16" class="octicon octicon-check color-fg-success m-2 d-none"><path d="${IconList["check"]}"></path></svg>
            </clipboard-copy>
            <div class="copy-feedback">Copied!</div>
        </div>
    `;

    const handleCodeElements = (selector = '') => {
        document.querySelectorAll(selector).forEach(codeElement => {
            const codeContent = codeElement.innerHTML;
            const newStructure = document.createElement('div');
            newStructure.className = 'snippet-clipboard-content position-relative overflow-auto';
            newStructure.innerHTML = createClipboardHTML(codeContent);

            const parentElement = codeElement.parentElement;
            if (selector.includes('highlight')) {
                parentElement.insertBefore(newStructure, codeElement.nextSibling);
                parentElement.removeChild(codeElement);
            } else {
                parentElement.parentElement.replaceChild(newStructure, parentElement);
            }
        });
    };

    handleCodeElements('pre.notranslate > code.notranslate');
    handleCodeElements('div.highlight > pre.notranslate');

    let currentFeedback = null;
    document.querySelectorAll('clipboard-copy').forEach(copyButton => {
        copyButton.addEventListener('click', () => {
            const codeContent = copyButton.closest('.snippet-clipboard-content').innerText;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = codeContent;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            const copyIcon = copyButton.querySelector('.octicon-copy');
            const checkIcon = copyButton.querySelector('.octicon-check');
            const copyFeedback = copyButton.nextElementSibling;

            if (currentFeedback && currentFeedback !== copyFeedback) {currentFeedback.style.display = 'none';}
            currentFeedback = copyFeedback;

            copyIcon.classList.add('d-none');
            checkIcon.classList.remove('d-none');
            copyFeedback.style.display = 'block';
            copyButton.style.borderColor = 'var(--color-success-fg)';

            setTimeout(() => {
                copyIcon.classList.remove('d-none');
                checkIcon.classList.add('d-none');
                copyFeedback.style.display = 'none';
                copyButton.style.borderColor = '';
            }, 2000);
        });
    });
});

</script>


</html>
